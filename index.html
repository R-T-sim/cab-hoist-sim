<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DXF レイヤビューア（静的表示 / mm / Y上＋）</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect width="64" height="64" rx="10" fill="%2310214a"/><path d="M10 46 L32 18 L54 46" stroke="%23ffd24d" stroke-width="6" fill="none"/></svg>'>
<style>
:root{ --bg:#0b1020; --panel:#121a33; --fg:#e8eef9; --muted:#9fb3d9; --accent:#3a76ff; --grid:#1b2445; --axis:#2f8bff; }
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:360px 1fr;gap:12px;padding:12px;height:100%}
.card{background:var(--panel);border-radius:14px;box-shadow:0 10px 28px rgba(0,0,0,.35);overflow:hidden}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px} h2{font-size:13px;color:var(--muted);margin:10px 0 6px}
.row{display:flex;gap:8px;align-items:center}
.row label{min-width:110px;font-size:12px;color:var(--muted)}
input[type=text]{flex:1;background:#0f1730;color:var(--fg);border:1px solid #24305a;border-radius:10px;padding:8px}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600}
.btn.ghost{background:#0f1730;border:1px solid #2a3a6a;color:var(--fg)}
.kbd{display:inline-block;padding:2px 6px;border:1px solid #2a3a6a;border-radius:8px;color:#9fb3d9;font-size:12px}
.small{font-size:12px;color:var(--muted)}
.layer{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px}
.sw{width:14px;height:14px;border-radius:4px;border:1px solid #0006}
hr{border:none;height:1px;background:#1c2343;margin:6px 0}
canvas{width:100%;height:100%;display:block;cursor:grab} canvas:active{cursor:grabbing}
.legend{font-size:12px;color:var(--muted)}
.badge{background:#10214a;color:#9fb3d9;border:1px solid #213064;padding:2px 6px;border-radius:10px;font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>DXF レイヤビューア</h1>
      <div class="legend">
        単位＝mm、座標系＝X右＋ / Y上＋。物理なしの純表示。<br>
        <span class="badge">操作</span> ドラッグ＝パン、<span class="kbd">ホイール</span>＝ズーム、<span class="kbd">F</span>＝フィット、<span class="kbd">R</span>＝初期表示。
      </div>
    </div>

    <h2>読込</h2>
    <div class="row">
      <label>GitHub内</label>
      <input id="path" type="text" value="位置関係整理ファイル.dxf" />
      <button id="load" class="btn">読み込み</button>
    </div>
    <div class="row">
      <label>ローカル</label>
      <input id="file" type="file" accept=".dxf" />
      <button id="fit" class="btn ghost">フィット</button>
      <button id="reset" class="btn ghost">R</button>
    </div>

    <h2>レイヤ</h2>
    <div id="layers"></div>

    <h2>表示</h2>
    <div class="row"><label>グリッド</label><input id="grid" type="checkbox" checked /> <span class="small">間隔 200mm</span></div>
    <div class="row"><label>原点/軸</label><input id="axes" type="checkbox" checked /></div>
    <div class="row"><label>注釈文字（TEXT/MTEXT）</label><input id="showtext" type="checkbox" /></div>
    <div class="row"><label>注釈ブロックを除外</label><input id="skipAnno" type="checkbox" checked /> <span class="small">（\*D… / 引出線 / 注釈 / 寸法）</span></div>

    <hr>
    <div id="info" class="small">未読込</div>
  </div>

  <div class="card"><canvas id="cv"></canvas></div>
</div>

<script>
// ===== Canvas =====
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1); let ready=false;
function resize(){const r=cv.getBoundingClientRect(); const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;} if(ready) draw();}
window.addEventListener('resize',resize);

// ===== Utils =====
const TAU=2*Math.PI;
const aciTable={0:"#cccccc",1:"#ff0000",2:"#ffff00",3:"#00ff00",4:"#00ffff",5:"#0000ff",6:"#ff00ff",7:"#ffffff",8:"#808080",9:"#808080"};
const aciColor=n=>aciTable[n]??(()=>{const h=(n%64)/64,s=0.7,v=0.95,i=Math.floor(h*6),f=h*6-i,p=v*(1-s),q=v*(1-s*f),t=v*(1-s*(1-f)),[r,g,b]=[[v,t,p],[q,v,p],[p,v,t],[p,q,v],[t,p,v],[v,p,q]][i%6].map(x=>Math.round(x*255));return`rgb(${r},${g},${b})`;})();
const I=[1,0,0,0,1,0];
const TRS=(tx,ty,ang=0,sx=1,sy=sx)=>{const c=Math.cos(ang),s=Math.sin(ang);return [c*sx,-s*sx,s*sy,c*sy,tx,ty];};
const mulT=(A,B)=>[A[0]*B[0]+A[2]*B[1],A[1]*B[0]+A[3]*B[1],A[0]*B[2]+A[2]*B[3],A[1]*B[2]+A[3]*B[3],A[0]*B[4]+A[2]*B[5]+A[4],A[1]*B[4]+A[3]*B[5]+A[5]];
const applyT=(T,p)=>({x:T[0]*p.x+T[2]*p.y+T[4], y:T[1]*p.x+T[3]*p.y+T[5]});

// ===== DXF Parser（BLOCK/INSERT, POLYLINE+VERTEX, ELLIPSE, SPLINE 近似）=====
function parseDXF(text){
  const L=text.split(/\r\n|\r|\n/); let i=0;
  const next=()=>{ if(i+1>=L.length) return null; const code=parseInt(L[i++].trim(),10); const val=(L[i++]??"").trim(); return {code,val}; };
  const take=(arr,c)=>arr.filter(p=>p.code===c).map(p=>p.val);
  const readPairs=()=>{ const arr=[]; while(true){ const p=next(); if(!p) break; if(p.code===0){ i-=2; break; } arr.push(p);} return arr; };

  const layersColor={}, blocks={}, ents=[];
  function parseSimple(type,pairs,layer,colorIdx){
    const by=c=>take(pairs,c);
    if(type==="LINE")     return {type:"line",layer,colorIdx,x1:+by(10)[0],y1:+by(20)[0],x2:+by(11)[0],y2:+by(21)[0]};
    if(type==="LWPOLYLINE"){ const xs=by(10).map(Number),ys=by(20).map(Number),closed=(parseInt(by(70)[0]||"0",10)&1)===1; return {type:"polyline",layer,colorIdx,pts:xs.map((x,k)=>({x,y:ys[k]})),closed};}
    if(type==="CIRCLE")  return {type:"circle",layer,colorIdx,cx:+by(10)[0],cy:+by(20)[0],r:+by(40)[0]};
    if(type==="ARC")     return {type:"arc",layer,colorIdx,cx:+by(10)[0],cy:+by(20)[0],r:+by(40)[0],a0:(+by(50)[0]||0)*Math.PI/180,a1:(+by(51)[0]||0)*Math.PI/180};
    if(type==="ELLIPSE"){ const cx=+by(10)[0],cy=+by(20)[0],ax=+by(11)[0],ay=+by(21)[0],ratio=+by(40)[0]||1,t0=+by(41)[0]||0,t1=+by(42)[0]||TAU,maj=Math.hypot(ax,ay),ang=Math.atan2(ay,ax),a=maj,b=maj*ratio,N=64,pts=[]; for(let k=0;k<=N;k++){const t=t0+(t1-t0)*k/N,x=a*Math.cos(t),y=b*Math.sin(t),c=Math.cos(ang),s=Math.sin(ang); pts.push({x:cx+c*x-s*y,y:cy+s*x+c*y});} return {type:"polyline",layer,colorIdx,pts,closed:false};}
    if(type==="SPLINE"){ const xs=by(10).map(Number),ys=by(20).map(Number),P=xs.map((x,i)=>({x,y:ys[i]})); if(P.length<=1) return null; const pts=[P[0]]; for(let i=0;i<P.length-1;i++){ const p0=P[Math.max(0,i-1)],p1=P[i],p2=P[i+1],p3=P[Math.min(P.length-1,i+2)]; for(let t=0;t<=1;t+=0.25){ const t2=t*t,t3=t2*t; const x=0.5*((2*p1.x)+(-p0.x+p2.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*t2+(-p0.x+3*p1.x-3*p2.x+p3.x)*t3); const y=0.5*((2*p1.y)+(-p0.y+p2.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*t2+(-p0.y+3*p1.y-3*p2.y+p3.y)*t3); pts.push({x,y}); } } pts.push(P[P.length-1]); return {type:"polyline",layer,colorIdx,pts,closed:false};}
    if(type==="TEXT"||type==="MTEXT"){ const x=+by(10)[0],y=+by(20)[0],h=+(by(40)[0]||by(42)[0]||"40"); let s=take(pairs,1).concat(take(pairs,3)).concat(take(pairs,4)).join("").replace(/\\P/g,"\n"); return {type:"text",layer,colorIdx,x,y,h,text:s};}
    return null;
  }
  function parseEntitiesInto(target){
    while(true){
      const p=next(); if(!p) break;
      if(p.code===0 && (p.val==="ENDSEC"||p.val==="ENDBLK")) break;
      if(p.code!==0) continue;
      const type=p.val;
      if(type==="POLYLINE"){ const head=readPairs(); const layer=(take(head,8)[0]||"0"); const colorIdx=(take(head,62)[0]!==undefined)?parseInt(take(head,62)[0],10):undefined; const pts=[]; while(true){ const q=next(); if(!q) break; if(q.code===0&&q.val==="VERTEX"){ const vp=readPairs(); pts.push({x:+take(vp,10)[0],y:+take(vp,20)[0]}); } else if(q.code===0&&q.val==="SEQEND"){ break; } } if(pts.length>=2) target.push({type:"polyline",layer,colorIdx,pts,closed:false}); continue; }
      if(type==="INSERT"){ const pairs=readPairs(), by=c=>take(pairs,c); target.push({type:"insert",layer:(by(8)[0]||"0"),colorIdx:(by(62)[0]!==undefined)?parseInt(by(62)[0],10):undefined,name:by(2)[0],x:+by(10)[0],y:+by(20)[0],sx:+(by(41)[0]||1),sy:+(by(42)[0]||by(41)[0]||1),ang:(+(by(50)[0]||0))*Math.PI/180}); continue; }
      // DIMENSION/VIEWPORT/WIPEOUT/POINT 等は描画しない
      const pairs=readPairs(); const layer=(take(pairs,8)[0]||"0"); const colorIdx=(take(pairs,62)[0]!==undefined)?parseInt(take(pairs,62)[0],10):undefined;
      const e=parseSimple(type,pairs,layer,colorIdx); if(e) target.push(e);
    }
  }
  while(true){
    const p=next(); if(!p) break;
    if(p.code===0 && p.val==="SECTION"){
      // section name
      let name=""; while(true){ const q=next(); if(!q) break; if(q.code===2){ name=q.val; break; } if(q.code===0){ i-=2; break; } }
      if(name==="TABLES"){
        while(true){ const q=next(); if(!q) break; if(q.code===0&&q.val==="ENDSEC") break;
          if(q.code===0&&q.val==="TABLE"){ let tname=""; let r; while((r=next())){ if(r.code===2){ tname=r.val; break; } }
            if(tname==="LAYER"){ while((r=next())){ if(r.code===0&&r.val==="ENDTAB") break; if(r.code===0&&r.val==="LAYER"){ const ps=readPairs(); const nm=take(ps,2)[0]; const col=(take(ps,62)[0]!==undefined)?parseInt(take(ps,62)[0],10):7; if(nm) layersColor[nm]=col; } } }
            else { while((r=next())){ if(r.code===0&&r.val==="ENDTAB") break; } }
        }
      } else if(name==="BLOCKS"){
        while(true){ const q=next(); if(!q) break; if(q.code===0&&q.val==="ENDSEC") break;
          if(q.code===0&&q.val==="BLOCK"){ const head=readPairs(); const bname=take(head,2)[0]||take(head,3)[0]; const items=[]; parseEntitiesInto(items); if(bname) blocks[bname]=items; }
        }
      } else if(name==="ENTITIES"){
        parseEntitiesInto(ents);
      } else {
        // skip others
        while(true){ const q2=next(); if(!q2) break; if(q2.code===0&&q2.val==="ENDSEC") break; }
      }
    }
  }
  const layers=[...new Set(ents.flatMap(e=>e.type==="insert" ? [e.layer, ...(blocks[e.name]?.map(be=>be.layer)||[])] : [e.layer]))].filter(Boolean).sort();
  const colors={}; layers.forEach(n=>{ const aci=(layersColor[n]!==undefined)?layersColor[n]:7; colors[n]=aciColor(aci); });
  return {entities:ents, layers, colors, blocks};
}

// ===== State =====
let model=null;
let showLayer={};
let showGrid=true, showAxes=true, showText=false; // ← 文字は既定OFF
let skipAnno=true;                                  // ← 注釈ブロック除外ON

let s=0.25, ox=0, oy=0; let worldBBox=null;
const sx_=(x)=>ox + x*s, sy_=(y)=>oy - y*s;

// 注釈ブロック判定
const isAnnoBlock = (name)=> !!name && /(^\*D\d+)|注釈|引出|寸法/i.test(name);

// BBox（INSERT 再帰・注釈除外対応）
function addBBox(b,x,y){ if(x<b.minx) b.minx=x; if(x>b.maxx) b.maxx=x; if(y<b.miny) b.miny=y; if(y>b.maxy) b.maxy=y; }
function bboxOfEntity(e,T){
  const b={minx:Infinity,miny:Infinity,maxx:-Infinity,maxy:-Infinity};
  const push=(p)=>addBBox(b,p.x,p.y);
  const line=(p1,p2)=>{push(applyT(T,p1)); push(applyT(T,p2));};
  if(e.type==="line"){ line({x:e.x1,y:e.y1},{x:e.x2,y:e.y2}); return b; }
  if(e.type==="polyline"){ e.pts.forEach(p=>push(applyT(T,p))); return b; }
  if(e.type==="circle"||e.type==="arc"){ const N=64,a0=(e.a0??0),a1=(e.a1??TAU),step=Math.max(8,Math.floor(Math.abs(a1-a0)*N/TAU)); for(let k=0;k<=step;k++){ const a=a0+(a1-a0)*k/step; push(applyT(T,{x:e.cx+e.r*Math.cos(a), y:e.cy+e.r*Math.sin(a)})); } return b; }
  if(e.type==="text" && showText){ push(applyT(T,{x:e.x,y:e.y})); return b; }
  if(e.type==="insert"){
    if(skipAnno && isAnnoBlock(e.name)) return b;
    const B=model.blocks[e.name]; if(!B) return b;
    const TT=mulT(T, TRS(e.x,e.y,e.ang,e.sx,e.sy));
    for(const be of B){ if(showLayer[be.layer]===false) continue; const bb=bboxOfEntity(be, TT); addBBox(b,bb.minx,bb.miny); addBBox(b,bb.maxx,bb.maxy); }
    return b;
  }
  return b;
}
function computeBBox(){
  if(!model){ worldBBox=null; return; }
  const b={minx:Infinity,miny:Infinity,maxx:-Infinity,maxy:-Infinity};
  for(const e of model.entities){
    if(e.type!=="insert" && showLayer[e.layer]===false) continue;
    if(e.type==="text" && !showText) continue;
    if(e.type==="insert" && skipAnno && isAnnoBlock(e.name)) continue;
    const bb=bboxOfEntity(e,I); addBBox(b,bb.minx,bb.miny); addBBox(b,bb.maxx,bb.maxy);
  }
  if(!isFinite(b.minx)) worldBBox={minx:-1000,maxx:1000,miny:-1000,maxy:1000};
  else worldBBox=b;
}
function fitToView(){
  if(!model) return;
  computeBBox();
  const m=worldBBox; const W=cv.width,H=cv.height,margin=60;
  const sx=(W-2*margin)/(m.maxx-m.minx||1), sy=(H-2*margin)/(m.maxy-m.miny||1);
  s=Math.max(0.1, Math.min(sx, sy));
  const cx=(m.minx+m.maxx)/2, cy=(m.miny+m.maxy)/2;
  ox=W/2 - cx*s; oy=H/2 + cy*s;
  draw();
}
function resetView(){ s=0.25; ox=cv.width*0.5; oy=cv.height*0.6; draw(); }

function drawGrid(){
  const step=200; const m=worldBBox||{minx:-4000,maxx:4000,miny:-2500,maxy:2500};
  const gx0=Math.floor(m.minx/step)*step, gx1=Math.ceil(m.maxx/step)*step, gy0=Math.floor(m.miny/step)*step, gy1=Math.ceil(m.maxy/step)*step;
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); ctx.lineWidth=1;
  for(let x=gx0;x<=gx1;x+=step){ ctx.beginPath(); ctx.moveTo(sx_(x), sy_(gy0)); ctx.lineTo(sx_(x), sy_(gy1)); ctx.stroke(); }
  for(let y=gy0;y<=gy1;y+=step){ ctx.beginPath(); ctx.moveTo(sx_(gx0), sy_(y)); ctx.lineTo(sx_(gx1), sy_(y)); ctx.stroke(); }
}
function drawAxes(){
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axis'); ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(sx_(0), sy_(-10000)); ctx.lineTo(sx_(0), sy_(10000)); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx_(-10000), sy_(0)); ctx.lineTo(sx_(10000), sy_(0)); ctx.stroke();
  ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(sx_(0), sy_(0), 4, 0, TAU); ctx.fill();
}
function drawEntity(e,T){
  const col=model.colors[e.layer]||"#ffffff"; ctx.strokeStyle=col; ctx.fillStyle=col; ctx.lineWidth=2;
  if(e.type==="line"){ const p1=applyT(T,{x:e.x1,y:e.y1}),p2=applyT(T,{x:e.x2,y:e.y2}); ctx.beginPath(); ctx.moveTo(sx_(p1.x),sy_(p1.y)); ctx.lineTo(sx_(p2.x),sy_(p2.y)); ctx.stroke(); return; }
  if(e.type==="polyline"){ if(e.pts.length<2) return; ctx.beginPath(); const a=applyT(T,e.pts[0]); ctx.moveTo(sx_(a.x),sy_(a.y)); for(let k=1;k<e.pts.length;k++){ const p=applyT(T,e.pts[k]); ctx.lineTo(sx_(p.x),sy_(p.y)); } if(e.closed) ctx.closePath(); ctx.stroke(); return; }
  if(e.type==="circle"||e.type==="arc"){ const c=applyT(T,{x:e.cx,y:e.cy}); const a0=-(e.a0??0),a1=-(e.a1??TAU); const r=e.r*s*Math.hypot(T[0],T[3]); ctx.beginPath(); if(e.type==="circle"){ ctx.arc(sx_(c.x),sy_(c.y),r,0,TAU); } else { ctx.arc(sx_(c.x),sy_(c.y),r,a0,a1,a1<a0); } ctx.stroke(); return; }
  if(e.type==="text" && showText){ const p=applyT(T,{x:e.x,y:e.y}); ctx.font=`${Math.max(10,e.h*s)}px ui-sans-serif`; ctx.fillStyle=col; for(const [i,ln] of String(e.text||"").split(/\r?\n/).entries()){ ctx.fillText(ln, sx_(p.x), sy_(p.y - i*e.h)); } return; }
  if(e.type==="insert"){ if(skipAnno && isAnnoBlock(e.name)) return; const B=model.blocks[e.name]; if(!B) return; const TT=mulT(T, TRS(e.x,e.y,e.ang,e.sx,e.sy)); for(const be of B){ if(showLayer[be.layer]===false) continue; drawEntity(be, TT); } }
}
function draw(){
  const W=cv.width,H=cv.height; ctx.clearRect(0,0,W,H);
  if(showGrid) drawGrid(); if(showAxes) drawAxes();
  if(!model) return;
  for(const e of model.entities){
    if(e.type!=="insert" && showLayer[e.layer]===false) continue;
    if(e.type==="text" && !showText) continue;
    drawEntity(e,I);
  }
}

// ===== UI =====
const layersDiv=document.getElementById('layers');
function buildLayerUI(){
  layersDiv.innerHTML="";
  if(!model){ layersDiv.textContent="未読込"; return; }
  const L=[...new Set(model.layers)]; if(!L.length){ layersDiv.textContent="レイヤ情報なし"; return; }
  L.forEach(name=>{
    const wrap=document.createElement('div'); wrap.className='layer';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=(showLayer[name]!==false);
    cb.onchange=()=>{ showLayer[name]=cb.checked; fitToView(); };
    const sw=document.createElement('div'); sw.className='sw'; sw.style.background=model.colors[name];
    const lab=document.createElement('span'); lab.textContent=name;
    wrap.append(cb, sw, lab); layersDiv.appendChild(wrap);
  });
}
function info(s){ document.getElementById('info').textContent=s; }
async function loadFromPath(p){
  const url=encodeURI(p); const res=await fetch(url);
  if(!res.ok) throw new Error(`fetch失敗: ${res.status} ${res.statusText} (${url})`);
  const text=await res.text(); model=parseDXF(text);
  buildLayerUI(); fitToView();
  info(`${model.layers.length} レイヤ / ${model.entities.length} エンティティ（ブロック対応）`);
}

// Hooks
document.getElementById('load').onclick=async()=>{ try{ await loadFromPath(document.getElementById('path').value.trim()); } catch(e){ console.error(e); info(`読込エラー: ${e.message}`); } };
document.getElementById('file').onchange=async(e)=>{ const f=e.target.files[0]; if(!f) return; const text=await f.text(); model=parseDXF(text); buildLayerUI(); fitToView(); info(`ローカル読込: ${f.name} / ${model.layers.length} レイヤ / ${model.entities.length} 件`); };
document.getElementById('fit').onclick=()=>fitToView();
document.getElementById('reset').onclick=()=>resetView();
document.getElementById('grid').onchange=(e)=>{ showGrid=e.target.checked; draw(); };
document.getElementById('axes').onchange=(e)=>{ showAxes=e.target.checked; draw(); };
document.getElementById('showtext').onchange=(e)=>{ showText=e.target.checked; fitToView(); };
document.getElementById('skipAnno').onchange=(e)=>{ skipAnno=e.target.checked; fitToView(); };

// パン/ズーム
let dragging=false,lastX=0,lastY=0;
cv.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY;});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{ if(!dragging) return; const dx=e.clientX-lastX,dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; ox+=dx; oy+=dy; draw(); });
cv.addEventListener('wheel',e=>{ e.preventDefault(); const k=Math.exp(-e.deltaY*0.0015); const mx=e.offsetX*DPR,my=e.offsetY*DPR,wx=(mx-ox)/s,wy=(my-oy)/s; s=Math.max(0.02,Math.min(5,s*k)); ox=mx-wx*s; oy=my-wy*s; draw(); },{passive:false});

// init
ready=true; resize(); draw();
loadFromPath(document.getElementById('path').value.trim()).catch(()=> info('左上の欄でパスを指定して「読み込み」を押してください。'));
</script>
</body>
</html>
