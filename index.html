<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D（要素数値情報.csv 1枚読み込み / mm / Y上＋）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:150px;font-size:12px;color:var(--muted)}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.kbd{display:inline-block;padding:2px 8px;border-radius:8px;background:#10172a;border:1px solid #1d2744;font-size:12px;color:var(--muted)}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
hr{border:none;height:1px;background:#1b2445;margin:8px 0}
input[type=file]{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑）＋ 吊具天秤＆アーム（赤）＋ CAB（青）</h1>
      <div class="legend">
        入力：<b>要素数値情報.csv</b>（1枚）／ 単位：mm（Y上＋）／ チェーンは剛体長。<br>
        ← / →：台車加減速（|v|≤0.3 m/s）、Space：ブレーキ、P：一時停止、R：リセット。
      </div>
    </div>

    <h2>CSV 読み込み</h2>
    <div class="row"><label>リポジトリ直下</label><button class="btn" id="loadUnified">1枚CSVを読み込み</button></div>
    <div class="row"><label>ローカル選択</label><input id="fileUnified" type="file" accept=".csv"><button class="btn secondary" id="applyUnified">反映</button></div>

    <h2>操作</h2>
    <div class="row" style="gap:12px;flex-wrap:wrap">
      <button class="btn secondary" id="pause">一時停止</button>
      <button class="btn secondary" id="reset">リセット</button>
    </div>

    <hr/>
    <div class="legend" id="status">未読込</div>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
// ========================= 基本ユーティリティ =========================
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1);
function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
window.addEventListener('resize',resize); resize();
function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}
const eps=1e-9;
function num(v){const n=parseFloat(String(v??'').replace(/[^\-+0-9.eE]/g,'')); return Number.isFinite(n)?n:0;}
function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function len(v){return Math.hypot(v.x,v.y);}
function I_rect(m,W,H){const w=W/1000,h=H/1000; return m*(w*w+h*h)/12;}

// ========================= モデルと状態 =========================
let model={
  anchors:{
    HOIST_TOP:{x:0,y:0},   // 原点（CSVの「チェーン/ホイスト交点」）
    HOOK:{x:0,y:-500},     // フック位置（描画用）
    FRAME_COM:{x:0,y:-560},
    PIVOT_L:{x:-700,y:-620}, PIVOT_R:{x:700,y:-620},
    CHAIN_A_LOCAL:{x:0,y:60} // フレーム座標でのチェーン取付
  },
  beam:{mass:180, span:2340, height:120},
  chain:{L:500},
  hoistRect:{Lh:400,Hh:200},
  arms:{ // 形状・制限（度）はCSVがあれば上書き
    L:{out:74, drop_out:190, drop_vert:350, shelf_in:85, lip_in:51, lip_up:39, minDeg:-180, maxDeg:-90, mass:20, cg:{x:-644,y:-819}},
    R:{out:74, drop_out:190, drop_vert:350, shelf_in:85, lip_in:51, lip_up:39, minDeg:-90,  maxDeg:0,   mass:20, cg:{x: 644,y:-819}}
  },
  shelves:[ // CAB×アーム受面の接触線（世界座標）
    {x0:-700,y0:-1160,x1:-689,y1:-1160}, // 左
    {x0: 700,y0:-1160,x1: 711,y1:-1160}  // 右
  ],
  cab:{mass:400,W:1800,H:1200,cg:{x:7,y:-1800}, mu:0.30, cphi:10},
  sim:{dt:1/600, g:9810},
  hoist:{a_cmd:3000, vmax:300, ccart:0.26}
};

// 状態（動）
let t=0, paused=false;
let xt=0, vt=0;                                   // 台車（= HOIST_TOP.x）
let xF=0, yF=-560, vFx=0, vFy=0, psi=0, wF=0;     // フレームCOMと姿勢
let cx=7, cy=-1800, cvx=0, cvy=0, phi=0, omega=0; // CAB

function I_frame(){return I_rect(model.beam.mass, model.beam.span, model.beam.height);}
function I_cab(){return I_rect(model.cab.mass, model.cab.W, model.cab.H);}

// フレーム座標→世界
function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}

// ========================= CSV 1枚のパーサ =========================
function parseUnifiedCSV(text){
  // 期待フォーマット：Name,Value,Unit（日本語名OK）
  const rows = text.split(/\r?\n/).filter(l=>l.trim()).map(l=>l.split(','));
  // 先頭行がヘッダかどうかを軽く判定
  let start=0; if(rows[0][0].match(/name|名称|Name/i)) start=1;
  const map={};
  for(let i=start;i<rows.length;i++){
    const [k,v,u]=[rows[i][0]?.trim(), rows[i][1]?.trim(), rows[i][2]?.trim()];
    if(!k) continue;
    map[k]= {val:num(v), unit:(u||'')};
  }
  // 取り出しヘルパ
  const get = (k,def=0)=> map[k]? num(map[k].val) : def;

  // アンカー類
  const HOIST_TOP={x:get('チェーン/ホイスト交点_X座標',0), y:get('チェーン/ホイスト交点_Y座標',0)};
  const HOOK     ={x:get('フック_X座標',0),            y:get('フック_Y座標',-500)};
  const chainFrame={x:get('チェーン/吊具天秤交点_X座標',0), y:get('チェーン/吊具天秤交点_Y座標',-500)};

  // 吊具天秤（フレーム）COMは「チェーン接点の真下に H/2 だけ下げる」と解釈
  const L1=get('吊具天秤長さ_L1',2340), H1=get('吊具天秤高さ_H1',120), m1=get('吊具天秤重量_m1',180);
  const frameCOM={x:chainFrame.x, y:chainFrame.y - H1/2};

  // 回転中心（世界座標）
  const PL={x:get('左側アーム回転中心座標_X',-700), y:get('左側アーム回転中心座標_Y',-620)};
  const PR={x:get('右側アーム回転中心座標_X', 700), y:get('右側アーム回転中心座標_Y',-620)};

  // アーム形状（左右）
  const L={ out:get('左側アーム外広がり_out',74), drop_out:get('左側アーム外広がり_drop',190),
            drop_vert:get('左側アーム垂直_drop',350), shelf_in:get('左側アーム_受面_in',85),
            lip_in:get('左側アーム_返し_in',51), lip_up:get('左側アーム_返し_up',39),
            mass:get('左側アーム重量_m_LH',20),
            cg:{x:get('左側アーム重心_G_LH_X座標',-644), y:get('左側アーム重心_G_LH_Y座標',-819)},
            minDeg:get('左側アーム最小角度',-180), maxDeg:get('左側アーム最大角度',-90) };
  const R={ out:get('右側アーム外広がり_out',74), drop_out:get('右側アーム外広がり_drop',190),
            drop_vert:get('右側アーム垂直_drop',350), shelf_in:get('右側アーム_受面_in',85),
            lip_in:get('右側アーム_返し_in',51), lip_up:get('右側アーム_返し_up',39),
            mass:get('右側アーム重量_m_LH',20),
            cg:{x:get('右側アーム重心_G_LH_X座標', 644), y:get('右側アーム重心_G_LH_Y座標',-819)},
            minDeg:get('右側アーム最小角度', -90), maxDeg:get('右側アーム最大角度',  0) };

  // CAB
  const cab={ mass:get('CAB重量_mcab',400), W:get('CAB幅_Lcab',1800), H:get('CAB高さ_Hcab',1200),
              cg:{x:get('CAB重心_Gcab_X座標',7), y:get('CAB重心_Gcab_Y座標',-1800)}, mu:0.30, cphi:10 };

  // 受面線分（CAB×アーム接触用）
  const shL={x0:get('CAB/左側アーム受面範囲P1_X座標',-700), y0:get('CAB/左側アーム受面範囲P1_Y座標',-1160),
             x1:get('CAB/左側アーム受面範囲P2_X座標',-689), y1:get('CAB/左側アーム受面範囲P2_Y座標',-1160)};
  const shR={x0:get('CAB/右側アーム受面範囲P3_X座標', 700), y0:get('CAB/右側アーム受面範囲P3_Y座標',-1160),
             x1:get('CAB/右側アーム受面範囲P4_X座標', 711), y1:get('CAB/右側アーム受面範囲P4_Y座標',-1160)};

  // ホイスト矩形
  const hoistRect={Lh:get('ホイスト長さ_Lh',400), Hh:get('ホイスト高さ_Hh',200)};

  // モデルへ反映
  model.anchors = {
    HOIST_TOP:HOIST_TOP, HOOK:HOOK,
    FRAME_COM:frameCOM, PIVOT_L:PL, PIVOT_R:PR,
    CHAIN_A_LOCAL:{x:chainFrame.x-frameCOM.x, y:chainFrame.y-frameCOM.y}
  };
  model.beam={mass:m1, span:L1, height:H1};
  model.chain={L:get('チェーン長さ_Lc',500)};
  model.hoistRect=hoistRect;
  model.arms={L,R};
  model.shelves=[shL,shR];
  model.cab=cab;

  // 状態リセット
  xt=HOIST_TOP.x; vt=0;
  xF=frameCOM.x; yF=frameCOM.y; vFx=0; vFy=0; psi=0; wF=0;
  cx=cab.cg.x; cy=cab.cg.y; cvx=0; cvy=0; phi=0; omega=0;
  // チェーンの幾何（長さ）を初回から満たす
  solveChainPosition(6);
  t=0;
}

// ========================= チェーン拘束（剛体長） =========================
function solveChainPosition(iter=3){
  for(let k=0;k<iter;k++){
    const H={x:xt,y:model.anchors.HOIST_TOP.y}, A=posF(model.anchors.CHAIN_A_LOCAL);
    let r=sub(A,H); let L=len(r); if(L<eps) return;
    const n={x:r.x/L,y:r.y/L}; const C=L - model.chain.L; if(Math.abs(C)<1e-6) return;
    const rA=rot(psi,model.anchors.CHAIN_A_LOCAL);
    const w=1/model.beam.mass, wrot=1/Math.max(1e-9,I_frame());
    const s = rA.x*n.y - rA.y*n.x;
    const denom = w + s*s*wrot;
    const dl=C/denom;
    xF -= w*n.x*dl; yF -= w*n.y*dl; psi -= wrot*s*dl;
  }
}
function solveChainVelocity(){
  const H={x:xt,y:model.anchors.HOIST_TOP.y}, vH={x:vt,y:0};
  const A=posF(model.anchors.CHAIN_A_LOCAL), vA=velAt(model.anchors.CHAIN_A_LOCAL);
  let r=sub(A,H), L=len(r); if(L<eps) return;
  const n={x:r.x/L,y:r.y/L};
  const vrel = ((vA.x-vH.x)*n.x + (vA.y-vH.y)*n.y)/1000;
  const rAm=rot(psi,model.anchors.CHAIN_A_LOCAL); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
  const K = 1/model.beam.mass + ((rAm_m.x*n.y - rAm_m.y*n.x)**2)/I_frame();
  let J = - vrel / K; if(J<0) J=0; // 張力のみ
  vFx += (-n.x*1000*J)/model.beam.mass; vFy += (-n.y*1000*J)/model.beam.mass;
  wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
}

// ========================= ステップ =========================
let keyL=false,keyR=false,brake=false;
addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='p'||e.key==='P')togglePause();if(e.key==='r'||e.key==='R')doReset();});
addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

function step(){
  const dt=model.sim.dt, gmm=model.sim.g;

  // 台車操作（運動学＋ダンピング）
  let u=0; if(keyL)u-=model.hoist.a_cmd; if(keyR)u+=model.hoist.a_cmd; if(brake)u+=-3*vt;
  vt += (u - model.hoist.ccart*vt)*dt;
  vt = Math.max(-model.hoist.vmax, Math.min(model.hoist.vmax, vt));
  xt += vt*dt;

  // 重力
  vFy += (gmm/1000)*dt;

  // チェーン拘束
  solveChainPosition(3);
  solveChainVelocity();

  // フレーム積分
  xF += vFx*dt; yF += vFy*dt; psi += wF*dt;

  // 受面との接触（左右 2 本の線分）
  const Icab=I_cab(); const mu=model.cab.mu;
  const cph=Math.cos(phi), sph=Math.sin(phi);
  const yTop = model.cab.H/2 - 80; // CABの溝深さ近似
  const px=[-model.cab.W/2 + 60, model.cab.W/2 - 60]; // 左右の接触代表点

  for(const seg of model.shelves){
    const x0=seg.x0, y0=seg.y0, x1=seg.x1, y1=seg.y1;
    const n={x:0,y:1}, tdir={x:1,y:0}; // 受面は水平前提
    for(const xoff of px){
      const P={x:cx + cph*xoff - sph*yTop, y:cy + sph*xoff + cph*yTop};
      if(P.x>=Math.min(x0,x1)-1e-3 && P.x<=Math.max(x0,x1)+1e-3 && P.y<=y0+1e-3){
        const r={x:(P.x-cx)/1000, y:(P.y-cy)/1000};
        const vP={x:cvx - omega*(P.y-cy), y:cvy + omega*(P.x-cx)};
        // 法線インパルス
        const vrelN = (vP.x*n.x + vP.y*n.y)/1000;
        const K = 1/model.cab.mass + ((r.x*n.y - r.y*n.x)**2)/Icab;
        const Jn = Math.max(0, -vrelN/K);
        cvx += (1000*Jn*n.x)/model.cab.mass; cvy += (1000*Jn*n.y)/model.cab.mass; omega += ((r.x*Jn*n.y - r.y*Jn*n.x))/Icab;
        // 摩擦
        const vrelT = (vP.x*tdir.x + vP.y*tdir.y)/1000;
        const Kt=1/model.cab.mass + ((r.x*tdir.y - r.y*tdir.x)**2)/Icab;
        const Jt_unc = - vrelT/Kt; const Jt = Math.max(-mu*Jn, Math.min(mu*Jn, Jt_unc));
        cvx += (1000*Jt*tdir.x)/model.cab.mass; cvy += (1000*Jt*tdir.y)/model.cab.mass; omega += ( (r.x*Jt*tdir.y - r.y*Jt*tdir.x))/Icab;
        // 軽い押し戻し
        const pen=y0-P.y; if(pen>0){ cy += pen*0.5; }
      }
    }
  }

  // CAB積分
  cvy += gmm*dt/1000;
  cx += cvx*dt; cy += cvy*dt;
  omega += (-model.cab.cphi*omega/Icab)*dt; phi += omega*dt;
}

// ========================= 描画 =========================
function draw(){
  const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
  ctx.clearRect(0,0,W,H);

  // grid
  ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1;
  for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
  for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();}
  ctx.restore();

  // hoist rectangle（中心：HOIST_TOPの上に Hh/2）
  const ht=model.anchors.HOIST_TOP;
  ctx.fillStyle='#26d07c';
  ctx.fillRect(sx(xt)-model.hoistRect.Lh*s/2, sy(ht.y+model.hoistRect.Hh/2)-model.hoistRect.Hh*s/2, model.hoistRect.Lh*s, model.hoistRect.Hh*s);
  // chain（HOIST_TOP→フレーム取付点）
  const A=posF(model.anchors.CHAIN_A_LOCAL);
  ctx.strokeStyle='#7bd6a8'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(ht.y)); ctx.lineTo(sx(A.x), sy(A.y)); ctx.stroke();

  // beam（天秤）
  ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi);
  ctx.fillStyle='#ff7070'; ctx.fillRect(-model.beam.span*s/2, -model.beam.height*s/2, model.beam.span*s, model.beam.height*s);
  ctx.restore();

  // arms（幾何: 回転中心→外広がり→落とし→縦棒→受面(内側)→返し(内＋上)）
  function drawArm(side){
    const isL=(side==='L'); const prm=model.arms[side];
    const root = isL ? model.anchors.PIVOT_L : model.anchors.PIVOT_R;
    // フレームに追従（梁方向をex, 上方向をey）
    const ex=rot(psi,{x:1,y:0}), ey=rot(psi,{x:0,y:1});
    const sgn = isL ? -1 : +1; // 外側が負/正
    let p={x:root.x, y:root.y};
    function step(dx,dy){ p={x:p.x+ex.x*dx+ey.x*dy, y:p.y+ex.y*dx+ey.y*dy}; ctx.lineTo(sx(p.x),sy(p.y)); return p; }
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(sx(p.x),sy(p.y));
    step(sgn*prm.out, -prm.drop_out);           // 外広がり＋落とし
    step(0, -prm.drop_vert);                    // 更に下へ
    const shelfStart=step(-sgn*prm.shelf_in, 0);// 受面は内側
    const shelfEnd  =step(-sgn*prm.lip_in,  prm.lip_up); // 返し（内側＋上）
    ctx.stroke();
    // 受面のハイライト
    ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(sx(shelfStart.x),sy(shelfStart.y)); ctx.lineTo(sx(shelfEnd.x),sy(shelfEnd.y)); ctx.stroke();
  }
  drawArm('L'); drawArm('R');

  // shelves（CSV指定の線分も表示）
  ctx.strokeStyle='#ffb3b3'; ctx.lineWidth=2;
  for(const seg of model.shelves){ ctx.beginPath(); ctx.moveTo(sx(seg.x0),sy(seg.y0)); ctx.lineTo(sx(seg.x1),sy(seg.y1)); ctx.stroke(); }

  // CAB
  ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
  ctx.fillStyle='rgba(127,182,255,0.9)'; ctx.fillRect(-model.cab.W*s/2, +model.cab.H*s/2 - model.cab.H*s, model.cab.W*s, model.cab.H*s);
  ctx.restore();
}

// ========================= ループ =========================
let last=performance.now(), acc=0;
function loop(now){
  const el=(now-last)/1000; last=now;
  if(!paused){ acc+=Math.min(el,0.12); const dt=model.sim.dt; while(acc>=dt){ step(); t+=dt; acc-=dt; } }
  draw(); requestAnimationFrame(loop);
}

// ========================= UI（読込・操作） =========================
function setStatus(s){ document.getElementById('status').textContent=s; }

async function loadUnifiedFromRepo(){
  try{
    const r=await fetch('要素数値情報.csv'); if(!r.ok){ setStatus('要素数値情報.csv が見つかりません'); return; }
    parseUnifiedCSV(await r.text());
    setStatus('要素数値情報.csv を読込みました');
  }catch(e){ console.error(e); setStatus('読込エラー: '+e.message); }
}
async function applyUnifiedFromLocal(){
  const f=document.getElementById('fileUnified').files[0];
  if(!f){ setStatus('CSVファイルを選択してください'); return; }
  const text=await f.text(); parseUnifiedCSV(text);
  setStatus('ローカルCSVを反映しました');
}

function togglePause(){ paused=!paused; document.getElementById('pause').textContent=paused?'再開':'一時停止'; }
function doReset(){
  // モデル値から状態のみリセット
  xt=model.anchors.HOIST_TOP.x; vt=0;
  xF=model.anchors.FRAME_COM.x; yF=model.anchors.FRAME_COM.y; vFx=0; vFy=0; psi=0; wF=0;
  cx=model.cab.cg.x; cy=model.cab.cg.y; cvx=0; cvy=0; phi=0; omega=0;
  solveChainPosition(6); t=0; paused=false;
  document.getElementById('pause').textContent='一時停止';
  setStatus('リセットしました');
}

document.getElementById('loadUnified').onclick=loadUnifiedFromRepo;
document.getElementById('applyUnified').onclick=applyUnifiedFromLocal;
document.getElementById('pause').onclick=togglePause;
document.getElementById('reset').onclick=doReset;

// 初期起動（既定の簡易値で起動しておき、読み込みで上書き）
requestAnimationFrame(loop);
</script>
</body>
</html>
