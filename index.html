<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D（直書きパラメータ / mm / Y上＋）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:360px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
hr{border:none;height:1px;background:#1b2445;margin:8px 0}
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <h1>ホイスト（緑）＋ 吊具天秤＆アーム（赤）＋ CAB（青）</h1>
    <div class="legend">
      この版は <b>CSVを使わず</b>、コード先頭の <b>PARAMS</b> に数値を直書きして使います。<br>
      単位=mm、原点=(0,0)=ホイストフック、Y上＋。チェーンは剛体長（伸び無し）。
    </div>
    <hr/>
    <div class="legend">
      操作：←/→=台車加減速（|v|≤0.3m/s）、Space=ブレーキ、P=一時停止、R=リセット
    </div>
    <div style="display:flex;gap:12px;flex-wrap:wrap">
      <button class="btn secondary" id="pause">一時停止</button>
      <button class="btn secondary" id="reset">リセット</button>
    </div>
    <hr/>
    <div id="status" class="small">準備完了。PARAMS を編集して保存→リロード。</div>
  </div>
  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
// ================================================================
//  PARAMS（ここを直接編集してください）
// ================================================================
const PARAMS = {
  // アンカー（世界座標, mm）
  anchors: {
    HOIST_ANCHOR: { x: 0,   y: 0   },   // 原点：ホイストフック
    CHAIN_ON_BEAM:{ x: 0,   y:-500 }    // チェーン/天秤交点（世界）
  },

  // 天秤（ビーム）
  beam: {
    mass: 180,        // kg
    span: 2340,       // 全長 L1
    height: 120       // 断面高さ H1（COMから上下±H1/2）
  },

  // チェーン（剛体長, 伸びない）
  chain: { L: 500 },  // mm

  // アーム幾何（支点→ひざ→縦棒→棚→返し）
  arm: {
    pivotWorldL: { x: -700, y: null }, // yは天秤下面（-H1/2）に自動合わせ
    pivotWorldR: { x:  700, y: null },
    out: 74,        // ひざ 外へ
    drop_out: 190,  // ひざ 下1
    drop_vert: 350, // 縦棒 下2
    shelf_in: 85,   // 棚 内向き（水平）
    lip_up: 39      // 返し 上向き（鉛直）
  },

  // CAB（質量と外形）
  cab: {
    mass: 400,      // kg
    W: 1800,        // mm
    H: 1200,        // mm
    notch: 0,       // 上面の“食い込み余白”（0でOK）
    mu: 0.35,       // 棚・返しとの摩擦係数
    cphi: 12        // 回転減衰 [N·m·s/rad]（簡易）
  },

  // ホイスト台車（運動学）
  hoist: { a_cmd: 2500, vmax: 300, ccart: 0.25 }, // mm/s^2, mm/s, 1/s

  // 物理・減衰
  sim: { dt: 1/600, g: 9810 }, // g=9.81m/s^2 → 9810 mm/s^2
  damp: { frame_lin: 0.6, frame_rot: 1.2, cab_lin: 0.08 },

  // 初期描画のホイスト箱サイズ（見た目のみ）
  hoistRect: { Lh: 400, Hh: 200 }
};

// ================================================================
//  以下はシミュレーション本体（編集不要）
// ================================================================
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1);
function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
window.addEventListener('resize',resize); resize();
function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}
function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function len(v){return Math.hypot(v.x,v.y);}
function clamp(v,lo,hi){return v<lo?lo:(v>hi?hi:v);}
function I_rect(m,W,H){const w=W/1000,h=H/1000; return m*(w*w+h*h)/12;}

// ---- モデル（PARAMS → 内部表現） ----
const model = {
  anchors: {
    HOIST_ANCHOR: { ...PARAMS.anchors.HOIST_ANCHOR },
    FRAME_COM:    { x: 0, y: 0 },                       // 計算で決定
    CHAIN_A_LOCAL:{ x: 0, y: 0 },                       // FRAME基準ローカル
    PIVOT_L_LOCAL:{ x: 0, y: 0 },
    PIVOT_R_LOCAL:{ x: 0, y: 0 }
  },
  hoistRect: { ...PARAMS.hoistRect },
  beam:  { ...PARAMS.beam },
  chain: { ...PARAMS.chain },
  arms:  { L:{}, R:{} },
  cab:   { ...PARAMS.cab },
  sim:   { ...PARAMS.sim },
  hoist: { ...PARAMS.hoist },
  damp:  { ...PARAMS.damp }
};

// FRAME_COM と各ローカル点を確定
function bakeFromParams(){
  // FRAME COM（チェーン接点は天秤断面中心から +H/2 上にある想定 → 交点y - H/2 がCOM）
  model.anchors.FRAME_COM = {
    x: PARAMS.anchors.CHAIN_ON_BEAM.x,
    y: PARAMS.anchors.CHAIN_ON_BEAM.y - model.beam.height/2
  };
  // チェーン接点（FRAMEローカル）
  model.anchors.CHAIN_A_LOCAL = {
    x: PARAMS.anchors.CHAIN_ON_BEAM.x - model.anchors.FRAME_COM.x,
    y: PARAMS.anchors.CHAIN_ON_BEAM.y - model.anchors.FRAME_COM.y
  };
  // アーム支点（世界x→ローカルx、ローカルyは下面固定）
  const pivotLocalY = -model.beam.height/2;
  model.anchors.PIVOT_L_LOCAL = { x: PARAMS.arm.pivotWorldL.x - model.anchors.FRAME_COM.x, y: pivotLocalY };
  model.anchors.PIVOT_R_LOCAL = { x: PARAMS.arm.pivotWorldR.x - model.anchors.FRAME_COM.x, y: pivotLocalY };
  // アーム寸法
  model.arms.L = { out:PARAMS.arm.out, drop_out:PARAMS.arm.drop_out, drop_vert:PARAMS.arm.drop_vert, shelf_in:PARAMS.arm.shelf_in, lip_up:PARAMS.arm.lip_up };
  model.arms.R = { ...model.arms.L };
}
bakeFromParams();

// ---- 状態量 ----
let t=0, paused=false;
let xt=model.anchors.HOIST_ANCHOR.x, vt=0;           // 台車
let xF=model.anchors.FRAME_COM.x, yF=model.anchors.FRAME_COM.y, vFx=0, vFy=0, psi=0, wF=0; // 天秤
let cx=0, cy=0, cvx=0, cvy=0, phi=0, omega=0;        // CAB

// ---- 補助 ----
function I_frame(){return I_rect(model.beam.mass, model.beam.span, model.beam.height);}
function I_cab(){return I_rect(model.cab.mass, model.cab.W, model.cab.H);}
function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}

// アームと接触面を生成
let shelves=[], lips=[], armPolys={L:[],R:[]}, armRoots={L:{x:0,y:0},R:{x:0,y:0}};
function buildArmsAndSurfaces(){
  shelves=[]; lips=[]; armPolys.L=[]; armPolys.R=[];
  const ex=rot(psi,{x:1,y:0}), ey=rot(psi,{x:0,y:1});
  function build(side){
    const prm=model.arms[side]; const sgn=(side==='L')?-1:+1;
    const pivotLocal=(side==='L')?model.anchors.PIVOT_L_LOCAL:model.anchors.PIVOT_R_LOCAL;
    let p=posF(pivotLocal); armRoots[side]=p;
    const poly=[{x:p.x,y:p.y}];
    function step(dx,dy){ p={x:p.x+ex.x*dx+ey.x*dy, y:p.y+ex.y*dx+ey.y*dy}; poly.push({x:p.x,y:p.y}); return p; }

    step(sgn*prm.out, -prm.drop_out);
    step(0, -prm.drop_vert);

    const shelfStart={x:p.x,y:p.y};
    step(-sgn*prm.shelf_in, 0);
    const shelfEnd={x:p.x,y:p.y};
    shelves.push({p0:shelfStart,p1:shelfEnd, n:ey, t:ex}); // 棚（上向き法線）

    const lipStart={x:p.x,y:p.y};
    step(0, prm.lip_up);
    const lipEnd={x:p.x,y:p.y};
    const n_out={x:sgn*ex.x, y:sgn*ex.y};
    lips.push({p0:lipStart,p1:lipEnd, n:n_out, t:ey});     // 返し（外向き法線）

    if(side==='L') armPolys.L=poly; else armPolys.R=poly;
  }
  build('L'); build('R');
}

// CABを「左右棚の内側に確実に掛かる」位置へ初期整列
function placeCabOnShelves(){
  buildArmsAndSurfaces();

  // 棚高さに合わせて y
  const shelfY = shelves.reduce((s,seg)=>s+((seg.p0.y+seg.p1.y)/2),0)/shelves.length;
  cy = shelfY - (model.cab.H/2 - model.cab.notch);

  // 左右棚を x 中点で判別
  const arr = shelves.map(seg=>({seg, midX:(seg.p0.x+seg.p1.x)/2})).sort((a,b)=>a.midX-b.midX);
  const sL = arr[0].seg, sR = arr[arr.length-1].seg;

  // 各棚の水平範囲
  const Lmin = Math.min(sL.p0.x, sL.p1.x), Lmax = Math.max(sL.p0.x, sL.p1.x);
  const Rmin = Math.min(sR.p0.x, sR.p1.x), Rmax = Math.max(sR.p0.x, sR.p1.x);

  // CAB 左右端が区間に入るための cx 範囲
  const W2 = model.cab.W/2 - 0.5; // 0.5mm の余裕
  const lo = Math.max(Lmin + W2, Rmin - W2);
  const hi = Math.min(Lmax + W2, Rmax - W2);

  if (hi >= lo) cx = (lo + hi)/2;
  else          cx = ((Lmin+Lmax)/2 + (Rmin+Rmax)/2)/2;  // フォールバック

  phi=0; omega=0; cvx=0; cvy=0;
}

// チェーン拘束（剛体長）
function solveChainPosition(iter=3){
  for(let k=0;k<iter;k++){
    const H={x:xt,y:model.anchors.HOIST_ANCHOR.y}, A=posF(model.anchors.CHAIN_A_LOCAL);
    const r=sub(A,H); const L=len(r)||1; const n={x:r.x/L,y:r.y/L}; const C=L-model.chain.L;
    if(Math.abs(C)<1e-6) return;
    const rA=rot(psi,model.anchors.CHAIN_A_LOCAL);
    const w=1/model.beam.mass, wrot=1/Math.max(1e-9,I_frame());
    const s = rA.x*n.y - rA.y*n.x;
    const dl=C/(w + s*s*wrot);
    xF -= w*n.x*dl; yF -= w*n.y*dl; psi -= wrot*s*dl;
  }
}
function solveChainVelocity(){
  const H={x:xt,y:model.anchors.HOIST_ANCHOR.y}, vH={x:vt,y:0};
  const A=posF(model.anchors.CHAIN_A_LOCAL), vA=velAt(model.anchors.CHAIN_A_LOCAL);
  const r=sub(A,H); const L=len(r)||1; const n={x:r.x/L,y:r.y/L};
  const vrel=((vA.x-vH.x)*n.x + (vA.y-vH.y)*n.y)/1000;
  const rAm=rot(psi,model.anchors.CHAIN_A_LOCAL); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
  const K=1/model.beam.mass + ((rAm_m.x*n.y - rAm_m.y*n.x)**2)/I_frame();
  let J=-vrel/K; if(J<0) J=0;
  vFx += (-n.x*1000*J)/model.beam.mass; vFy += (-n.y*1000*J)/model.beam.mass;
  wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
}

// ステップ
let keyL=false,keyR=false,brake=false;
addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='p'||e.key==='P')togglePause();if(e.key==='r'||e.key==='R')doReset();});
addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

function step(){
  const dt=model.sim.dt, gmm=model.sim.g;

  // 台車（運動学）
  let u=0; if(keyL)u-=model.hoist.a_cmd; if(keyR)u+=model.hoist.a_cmd; if(brake)u+=-3*vt;
  vt += (u - model.hoist.ccart*vt)*dt;
  vt = clamp(vt, -model.hoist.vmax, model.hoist.vmax);
  xt += vt*dt;

  // 天秤に重力
  vFy += (-gmm/1000)*dt;

  // チェーン拘束
  solveChainPosition(3);
  solveChainVelocity();

  // 減衰
  vFx += -model.damp.frame_lin*vFx*dt;
  vFy += -model.damp.frame_lin*vFy*dt;
  wF  += -model.damp.frame_rot*wF*dt;

  // 積分
  xF += vFx*dt; yF += vFy*dt; psi += wF*dt;

  // 接触面更新
  buildArmsAndSurfaces();

  // CAB × 棚/返し
  const Icab = I_cab();
  const cph=Math.cos(phi), sph=Math.sin(phi);
  const yTop = model.cab.H/2 - model.cab.notch;

  function contactLine(P, n, tdir){
    const r={x:(P.x-cx)/1000, y:(P.y-cy)/1000};
    const vP={x:cvx - omega*(P.y-cy), y:cvy + omega*(P.x-cx)};
    const vrelN=(vP.x*n.x + vP.y*n.y)/1000;
    const K=1/model.cab.mass + ((r.x*n.y - r.y*n.x)**2)/Icab;
    const Jn=Math.max(0, -vrelN/K);
    cvx += (1000*Jn*n.x)/model.cab.mass; cvy += (1000*Jn*n.y)/model.cab.mass; omega += ((r.x*Jn*n.y - r.y*Jn*n.x))/Icab;
    const vrelT=(vP.x*tdir.x + vP.y*tdir.y)/1000;
    const Kt=1/model.cab.mass + ((r.x*tdir.y - r.y*tdir.x)**2)/Icab;
    const Jt_unc=-vrelT/Kt; const mu=model.cab.mu; const Jt=clamp(Jt_unc,-mu*Jn,mu*Jn);
    cvx += (1000*Jt*tdir.x)/model.cab.mass; cvy += (1000*Jt*tdir.y)/model.cab.mass; omega += ((r.x*Jt*tdir.y - r.y*Jt*tdir.x))/Icab;
  }

  const xSamples=[-0.5, -0.25, 0, 0.25, 0.5].map(k=>k*model.cab.W*0.98);

  // 棚（上面）との接触
  for(const seg of shelves){
    const sVec=sub(seg.p1, seg.p0); const Ls=len(sVec)||1;
    const tdir={x:sVec.x/Ls, y:sVec.y/Ls}; const n=seg.n;
    for(const xo of xSamples){
      const P={ x:cx + cph*xo - sph*yTop, y:cy + sph*xo + cph*yTop };
      const rel=sub(P, seg.p0);
      const u=clamp( (rel.x*tdir.x + rel.y*tdir.y), 0, Ls );
      const Q={x: seg.p0.x + tdir.x*u, y: seg.p0.y + tdir.y*u};
      const sep = (P.x-Q.x)*n.x + (P.y-Q.y)*n.y;
      if(sep <= 1e-3){ const pen=-sep; cx += n.x*pen*0.5; cy += n.y*pen*0.5; contactLine(P, n, tdir); }
    }
  }

  // 返し（左右端）
  const corner=[-0.5*model.cab.W*0.98, +0.5*model.cab.W*0.98];
  for(const seg of lips){
    const sVec=sub(seg.p1, seg.p0); const Ls=len(sVec)||1;
    const tdir={x:sVec.x/Ls, y:sVec.y/Ls}; const n=seg.n;
    for(const xo of corner){
      const P={ x:cx + cph*xo - sph*yTop, y:cy + sph*xo + cph*yTop };
      const rel=sub(P, seg.p0);
      const u=clamp( (rel.x*tdir.x + rel.y*tdir.y), 0, Ls );
      const Q={x: seg.p0.x + tdir.x*u, y: seg.p0.y + tdir.y*u};
      const sep = (P.x-Q.x)*n.x + (P.y-Q.y)*n.y;
      if(sep <= 1e-3){ const pen=-sep; cx += n.x*pen*0.5; cy += n.y*pen*0.5; contactLine(P, n, tdir); }
    }
  }

  // CAB 自由運動
  cvy += (-gmm/1000)*dt;
  cvx += -model.damp.cab_lin*cvx*dt;
  cvy += -model.damp.cab_lin*cvy*dt;
  cx += cvx*dt; cy += cvy*dt;
  omega += (-model.cab.cphi*omega/Icab)*dt; phi += omega*dt;
}

// 描画
function draw(){
  const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
  ctx.clearRect(0,0,W,H);
  // grid
  ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1;
  for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
  for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();}
  ctx.restore();

  // hoist box
  const ha=model.anchors.HOIST_ANCHOR;
  ctx.fillStyle='#26d07c';
  ctx.fillRect(sx(xt)-model.hoistRect.Lh*s/2, sy(ha.y+PARAMS.hoistRect.Hh), model.hoistRect.Lh*s, model.hoistRect.Hh*s);
  // chain
  const A=posF(model.anchors.CHAIN_A_LOCAL);
  ctx.strokeStyle='#7bd6a8'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(ha.y)); ctx.lineTo(sx(A.x), sy(A.y)); ctx.stroke();

  // beam
  ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi);
  ctx.fillStyle='#ff7070'; ctx.fillRect(-model.beam.span*s/2, -model.beam.height*s/2, model.beam.span*s, model.beam.height*s);
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // CAB
  ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
  ctx.fillStyle='rgba(127,182,255,0.92)'; ctx.fillRect(-model.cab.W*s/2, +model.cab.H*s/2 - model.cab.H*s, model.cab.W*s, model.cab.H*s);
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill(); ctx.restore();

  // arms
  function drawPoly(poly){
    if(!poly.length) return;
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(sx(poly[0].x),sy(poly[0].y));
    for(let i=1;i<poly.length;i++) ctx.lineTo(sx(poly[i].x),sy(poly[i].y));
    ctx.stroke();
  }
  drawPoly(armPolys.L); drawPoly(armPolys.R);

  // shelves / lips（前面でハイライト）
  ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8;
  for(const seg of shelves){ ctx.beginPath(); ctx.moveTo(sx(seg.p0.x),sy(seg.p0.y)); ctx.lineTo(sx(seg.p1.x),sy(seg.p1.y)); ctx.stroke(); }
  ctx.strokeStyle='#ffd0d0'; ctx.lineWidth=6;
  for(const seg of lips){ ctx.beginPath(); ctx.moveTo(sx(seg.p0.x),sy(seg.p0.y)); ctx.lineTo(sx(seg.p1.x),sy(seg.p1.y)); ctx.stroke(); }
}

// ループ・UI
let last=performance.now(), acc=0;
function loop(now){
  const el=(now-last)/1000; last=now;
  if(!paused){ acc+=Math.min(el,0.12); const dt=model.sim.dt; while(acc>=dt){ step(); t+=dt; acc-=dt; } }
  draw(); requestAnimationFrame(loop);
}
function setStatus(s){ document.getElementById('status').textContent=s; }
function togglePause(){ paused=!paused; document.getElementById('pause').textContent=paused?'再開':'一時停止'; }
function doReset(){
  // 初期位置（天秤COM・ホイスト・CAB整列）
  xt=model.anchors.HOIST_ANCHOR.x; vt=0; psi=0; wF=0; vFx=0; vFy=0;
  xF=model.anchors.FRAME_COM.x; yF=model.anchors.FRAME_COM.y;
  placeCabOnShelves();
  solveChainPosition(6);
  t=0; paused=false; document.getElementById('pause').textContent='一時停止';
  setStatus('リセット完了（PARAMSの値で初期整列）');
}
document.getElementById('pause').onclick=togglePause;
document.getElementById('reset').onclick=doReset;

// 初期整列して開始
placeCabOnShelves();
solveChainPosition(6);
requestAnimationFrame(loop);
</script>
</body>
</html>
