<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D（要素数値情報.csv 1枚 / mm / Y上＋）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:150px;font-size:12px;color:var(--muted)}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
hr{border:none;height:1px;background:#1b2445;margin:8px 0}
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑）＋ 吊具天秤＆アーム（赤）＋ CAB（青）</h1>
      <div class="legend">
        入力：<b>要素数値情報.csv</b>（1枚）／ 単位：mm（Y上＋）／ チェーンは剛体長。<br>
        ← / →：台車加減速（|v|≤0.3 m/s）、Space：ブレーキ、P：一時停止、R：リセット。
      </div>
    </div>

    <h2>CSV 読み込み</h2>
    <div class="row"><label>リポジトリ直下</label><button class="btn" id="loadUnified">1枚CSVを読み込み</button></div>
    <div class="row"><label>ローカル選択</label><input id="fileUnified" type="file" accept=".csv"><button class="btn secondary" id="applyUnified">反映</button></div>

    <h2>操作</h2>
    <div class="row" style="gap:12px;flex-wrap:wrap">
      <button class="btn secondary" id="pause">一時停止</button>
      <button class="btn secondary" id="reset">リセット</button>
    </div>

    <hr/>
    <div class="legend" id="status">CSV自動読み込み待ち...</div>
    <div class="small">デバッグ点：HOISTアンカー / 天秤COM / アーム支点 / CAB重心</div>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
// ===== 基本ユーティリティ =====
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1);
function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
window.addEventListener('resize',resize); resize();
function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}
function num(v){const n=parseFloat(String(v??'').replace(/[^\-+0-9.eE]/g,'')); return Number.isFinite(n)?n:0;}
function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function len(v){return Math.hypot(v.x,v.y);}
function clamp(v,lo,hi){return v<lo?lo:(v>hi?hi:v);}
function I_rect(m,W,H){const w=W/1000,h=H/1000; return m*(w*w+h*h)/12;}

// ===== モデルと状態 =====
let model={
  anchors:{
    HOIST_ANCHOR:{x:0,y:0},
    FRAME_COM:{x:0,y:-560},
    CHAIN_A_LOCAL:{x:0,y:60},
    PIVOT_L_LOCAL:{x:-700,y:-60}, // 読込時に -H1/2 で上書き
    PIVOT_R_LOCAL:{x: 700,y:-60}
  },
  hoistRect:{Lh:400,Hh:200},
  beam:{mass:180, span:2340, height:120},
  chain:{L:500},
  arms:{
    L:{out:74, drop_out:190, drop_vert:350, shelf_in:85, lip_up:39},
    R:{out:74, drop_out:190, drop_vert:350, shelf_in:85, lip_up:39}
  },
  cab:{mass:400,W:1800,H:1200,cg:{x:7,y:-1800}, mu:0.35, cphi:12, notch:0},
  sim:{dt:1/600, g:9810},
  hoist:{a_cmd:2500, vmax:300, ccart:0.25},
  damp:{frame_lin:0.6, frame_rot:1.2, cab_lin:0.08}
};

// 状態
let t=0, paused=false;
let xt=0, vt=0;
let xF=0, yF=-560, vFx=0, vFy=0, psi=0, wF=0;
let cx=7, cy=-1800, cvx=0, cvy=0, phi=0, omega=0;

function I_frame(){return I_rect(model.beam.mass, model.beam.span, model.beam.height);}
function I_cab(){return I_rect(model.cab.mass, model.cab.W, model.cab.H);}
function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}

// ===== アーム幾何（棚=水平 / 返し=鉛直） =====
let shelves=[], lips=[], armPolys={L:[],R:[]}, armRoots={L:{x:0,y:0},R:{x:0,y:0}};
function buildArmsAndSurfaces(){
  shelves=[]; lips=[]; armPolys.L=[]; armPolys.R=[];
  const ex=rot(psi,{x:1,y:0}), ey=rot(psi,{x:0,y:1});
  function build(side){
    const prm=model.arms[side]; const sgn=(side==='L')?-1:+1;
    const pivotLocal=(side==='L')?model.anchors.PIVOT_L_LOCAL:model.anchors.PIVOT_R_LOCAL;
    let p=posF(pivotLocal); armRoots[side]=p;
    const poly=[{x:p.x,y:p.y}];
    function step(dx,dy){ p={x:p.x+ex.x*dx+ey.x*dy, y:p.y+ex.y*dx+ey.y*dy}; poly.push({x:p.x,y:p.y}); return p; }

    step(sgn*prm.out, -prm.drop_out);
    step(0, -prm.drop_vert);

    const shelfStart={x:p.x,y:p.y};
    step(-sgn*prm.shelf_in, 0);
    const shelfEnd={x:p.x,y:p.y};
    shelves.push({p0:shelfStart,p1:shelfEnd, n:ey, t:ex});

    const lipStart={x:p.x,y:p.y}; // 返し基点（水平棚の端）
    step(0, prm.lip_up);
    const lipEnd={x:p.x,y:p.y};
    const n_out={x:sgn*ex.x, y:sgn*ex.y};
    lips.push({p0:lipStart,p1:lipEnd, n:n_out, t:ey});

    if(side==='L') armPolys.L=poly; else armPolys.R=poly;
  }
  build('L'); build('R');
}

// ===== CSV 1枚読み込み =====
function parseUnifiedCSV(text){
  const rows = text.split(/\r?\n/).filter(l=>l.trim()).map(l=>l.split(','));
  let start=0; if(rows[0][0]?.match(/name|名称|Name/i)) start=1;
  const map={}; for(let i=start;i<rows.length;i++){ const k=rows[i][0]?.trim(); if(!k) continue; map[k]={val:num(rows[i][1])}; }
  const get=(k,def=0)=> map[k]? num(map[k].val) : def;

  const HA={x:get('チェーン/ホイスト交点_X座標',0), y:get('チェーン/ホイスト交点_Y座標',0)};
  const cf={x:get('チェーン/吊具天秤交点_X座標',0), y:get('チェーン/吊具天秤交点_Y座標',-500)};
  const L1=get('吊具天秤長さ_L1',2340), H1=get('吊具天秤高さ_H1',120), m1=get('吊具天秤重量_m1',180);
  const frameCOM={x:cf.x, y:cf.y - H1/2};

  // 支点Yは常に天秤下面（-H1/2）に固定。XはCSV相対。
  const PLw={x:get('左側アーム回転中心座標_X',-700), y:get('左側アーム回転中心座標_Y',-620)};
  const PRw={x:get('右側アーム回転中心座標_X', 700), y:get('右側アーム回転中心座標_Y',-620)};
  const pivotLocalY = -H1/2;
  const PLI={x:PLw.x-frameCOM.x, y:pivotLocalY};
  const PRI={x:PRw.x-frameCOM.x, y:pivotLocalY};

  model.anchors={HOIST_ANCHOR:HA, FRAME_COM:frameCOM, CHAIN_A_LOCAL:{x:cf.x-frameCOM.x, y:cf.y-frameCOM.y},
                 PIVOT_L_LOCAL:PLI, PIVOT_R_LOCAL:PRI};
  model.hoistRect={Lh:get('ホイスト長さ_Lh',400), Hh:get('ホイスト高さ_Hh',200)};
  model.beam={mass:m1, span:L1, height:H1};
  model.chain={L:get('チェーン長さ_Lc',500)};

  model.cab.mass = get('CAB重量_mcab',400);
  model.cab.W    = get('CAB幅_Lcab',1800);
  model.cab.H    = get('CAB高さ_Hcab',1200);
  model.cab.cg.x = get('CAB重心_Gcab_X座標',7);
  model.cab.cg.y = get('CAB重心_Gcab_Y座標',-1800);

  // 状態初期化（返しxで中央寄せ、棚高さでy決定）
  xt=HA.x; vt=0; xF=frameCOM.x; yF=frameCOM.y; psi=0; wF=0; vFx=0; vFy=0;
  phi=0; omega=0; cvx=0; cvy=0;

  buildArmsAndSurfaces();

  // ★ ここが肝：左右の返し基点 x（lips[].p0.x）で中央寄せ
  const lipXs = lips.map(seg=>seg.p0.x);
  const lipL = Math.min(...lipXs), lipR = Math.max(...lipXs);
  const midX = (lipL + lipR)/2;

  // 棚高さは水平方向なので平均でよい
  const shelfY = shelves.reduce((s,seg)=> s + ((seg.p0.y+seg.p1.y)/2), 0) / shelves.length;

  cx = midX;
  cy = shelfY - (model.cab.H/2 - model.cab.notch);

  // チェーン長拘束を満たす微調整（天秤位置を微修正）
  solveChainPosition(6);

  t=0;
  setStatus('要素数値情報.csv を読込みました（初期：返し中央・棚高さに正確整列）');
}

// ===== チェーン拘束（剛体長） =====
function solveChainPosition(iter=3){
  for(let k=0;k<iter;k++){
    const H={x:xt,y:model.anchors.HOIST_ANCHOR.y}, A=posF(model.anchors.CHAIN_A_LOCAL);
    const r=sub(A,H); const L=len(r)||1; const n={x:r.x/L,y:r.y/L}; const C=L-model.chain.L;
    if(Math.abs(C)<1e-6) return;
    const rA=rot(psi,model.anchors.CHAIN_A_LOCAL);
    const w=1/model.beam.mass, wrot=1/Math.max(1e-9,I_frame());
    const s = rA.x*n.y - rA.y*n.x;
    const dl=C/(w + s*s*wrot);
    xF -= w*n.x*dl; yF -= w*n.y*dl; psi -= wrot*s*dl;
  }
}
function solveChainVelocity(){
  const H={x:xt,y:model.anchors.HOIST_ANCHOR.y}, vH={x:vt,y:0};
  const A=posF(model.anchors.CHAIN_A_LOCAL), vA=velAt(model.anchors.CHAIN_A_LOCAL);
  const r=sub(A,H); const L=len(r)||1; const n={x:r.x/L,y:r.y/L};
  const vrel=((vA.x-vH.x)*n.x + (vA.y-vH.y)*n.y)/1000;
  const rAm=rot(psi,model.anchors.CHAIN_A_LOCAL); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
  const K=1/model.beam.mass + ((rAm_m.x*n.y - rAm_m.y*n.x)**2)/I_frame();
  let J=-vrel/K; if(J<0) J=0;
  vFx += (-n.x*1000*J)/model.beam.mass; vFy += (-n.y*1000*J)/model.beam.mass;
  wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
}

// ===== ステップ（物理） =====
let keyL=false,keyR=false,brake=false;
addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='p'||e.key==='P')togglePause();if(e.key==='r'||e.key==='R')doReset();});
addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

function step(){
  const dt=model.sim.dt, gmm=model.sim.g;

  // 台車
  let u=0; if(keyL)u-=model.hoist.a_cmd; if(keyR)u+=model.hoist.a_cmd; if(brake)u+=-3*vt;
  vt += (u - model.hoist.ccart*vt)*dt;
  vt = clamp(vt, -model.hoist.vmax, model.hoist.vmax);
  xt += vt*dt;

  // 重力（天秤）
  vFy += (-gmm/1000)*dt;

  // チェーン拘束
  solveChainPosition(3);
  solveChainVelocity();

  // 天秤減衰
  vFx += -model.damp.frame_lin*vFx*dt;
  vFy += -model.damp.frame_lin*vFy*dt;
  wF  += -model.damp.frame_rot*wF*dt;

  // 積分
  xF += vFx*dt; yF += vFy*dt; psi += wF*dt;

  // 受面再生成
  buildArmsAndSurfaces();

  // ===== CAB × 棚/返し（多点接触） =====
  const Icab = I_cab();
  const ex=rot(psi,{x:1,y:0}), ey=rot(psi,{x:0,y:1});
  const cph=Math.cos(phi), sph=Math.sin(phi);
  const yTop = model.cab.H/2 - model.cab.notch;

  function contactLine(P, n, tdir){
    const r={x:(P.x-cx)/1000, y:(P.y-cy)/1000};
    const vP={x:cvx - omega*(P.y-cy), y:cvy + omega*(P.x-cx)};
    const vrelN=(vP.x*n.x + vP.y*n.y)/1000;
    const K=1/model.cab.mass + ((r.x*n.y - r.y*n.x)**2)/Icab;
    const Jn=Math.max(0, -vrelN/K);
    cvx += (1000*Jn*n.x)/model.cab.mass; cvy += (1000*Jn*n.y)/model.cab.mass; omega += ((r.x*Jn*n.y - r.y*Jn*n.x))/Icab;
    const vrelT=(vP.x*tdir.x + vP.y*tdir.y)/1000;
    const Kt=1/model.cab.mass + ((r.x*tdir.y - r.y*tdir.x)**2)/Icab;
    const Jt_unc=-vrelT/Kt; const mu=model.cab.mu; const Jt=clamp(Jt_unc,-mu*Jn,mu*Jn);
    cvx += (1000*Jt*tdir.x)/model.cab.mass; cvy += (1000*Jt*tdir.y)/model.cab.mass; omega += ((r.x*Jt*tdir.y - r.y*Jt*tdir.x))/Icab;
  }

  const xSamples=[-0.5, -0.25, 0, 0.25, 0.5].map(k=>k*model.cab.W*0.98);

  // 棚
  for(const seg of shelves){
    const sVec=sub(seg.p1, seg.p0); const Ls=len(sVec)||1;
    const tdir={x:sVec.x/Ls, y:sVec.y/Ls}; const n=seg.n;
    for(const xo of xSamples){
      const P={ x:cx + cph*xo - sph*yTop, y:cy + sph*xo + cph*yTop };
      const rel=sub(P, seg.p0);
      const u=clamp( (rel.x*tdir.x + rel.y*tdir.y), 0, Ls );
      const Q={x: seg.p0.x + tdir.x*u, y: seg.p0.y + tdir.y*u};
      const sep = (P.x-Q.x)*n.x + (P.y-Q.y)*n.y;
      if(sep <= 1e-3){ const pen=-sep; cx += n.x*pen*0.5; cy += n.y*pen*0.5; contactLine(P, n, tdir); }
    }
  }

  // 返し（左右コーナ付近）
  const corner=[-0.5*model.cab.W*0.98, +0.5*model.cab.W*0.98];
  for(const seg of lips){
    const sVec=sub(seg.p1, seg.p0); const Ls=len(sVec)||1;
    const tdir={x:sVec.x/Ls, y:sVec.y/Ls}; const n=seg.n;
    for(const xo of corner){
      const P={ x:cx + cph*xo - sph*yTop, y:cy + sph*xo + cph*yTop };
      const rel=sub(P, seg.p0);
      const u=clamp( (rel.x*tdir.x + rel.y*tdir.y), 0, Ls );
      const Q={x: seg.p0.x + tdir.x*u, y: seg.p0.y + tdir.y*u};
      const sep = (P.x-Q.x)*n.x + (P.y-Q.y)*n.y;
      if(sep <= 1e-3){ const pen=-sep; cx += n.x*pen*0.5; cy += n.y*pen*0.5; contactLine(P, n, tdir); }
    }
  }

  // CAB 自由運動
  cvy += (-gmm/1000)*dt;
  cvx += -model.damp.cab_lin*cvx*dt;
  cvy += -model.damp.cab_lin*cvy*dt;
  cx += cvx*dt; cy += cvy*dt;
  omega += (-model.cab.cphi*omega/Icab)*dt; phi += omega*dt;
}

// ===== 描画 =====
function draw(){
  const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
  ctx.clearRect(0,0,W,H);

  // grid
  ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1;
  for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
  for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();}
  ctx.restore();

  // hoist
  const ha=model.anchors.HOIST_ANCHOR;
  const topY = ha.y + model.hoistRect.Hh;
  ctx.fillStyle='#26d07c';
  ctx.fillRect(sx(xt)-model.hoistRect.Lh*s/2, sy(topY), model.hoistRect.Lh*s, model.hoistRect.Hh*s);

  // chain
  const A=posF(model.anchors.CHAIN_A_LOCAL);
  ctx.strokeStyle='#7bd6a8'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(ha.y)); ctx.lineTo(sx(A.x), sy(A.y)); ctx.stroke();

  // beam
  ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi);
  ctx.fillStyle='#ff7070'; ctx.fillRect(-model.beam.span*s/2, -model.beam.height*s/2, model.beam.span*s, model.beam.height*s);
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // CAB（先に描画）
  ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
  ctx.fillStyle='rgba(127,182,255,0.92)'; ctx.fillRect(-model.cab.W*s/2, +model.cab.H*s/2 - model.cab.H*s, model.cab.W*s, model.cab.H*s);
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // arms
  function drawPoly(poly){
    if(!poly.length) return;
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(sx(poly[0].x),sy(poly[0].y));
    for(let i=1;i<poly.length;i++) ctx.lineTo(sx(poly[i].x),sy(poly[i].y));
    ctx.stroke();
  }
  drawPoly(armPolys.L); drawPoly(armPolys.R);

  // shelves / lips（前面）
  ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8;
  for(const seg of shelves){ ctx.beginPath(); ctx.moveTo(sx(seg.p0.x),sy(seg.p0.y)); ctx.lineTo(sx(seg.p1.x),sy(seg.p1.y)); ctx.stroke(); }
  ctx.strokeStyle='#ffd0d0'; ctx.lineWidth=6;
  for(const seg of lips){ ctx.beginPath(); ctx.moveTo(sx(seg.p0.x),sy(seg.p0.y)); ctx.lineTo(sx(seg.p1.x),sy(seg.p1.y)); ctx.stroke(); }

  // 支点・アンカー
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(sx(armRoots.L.x),sy(armRoots.L.y),3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(sx(armRoots.R.x),sy(armRoots.R.y),3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#7bd6a8'; ctx.beginPath(); ctx.arc(sx(xt),sy(ha.y),3,0,Math.PI*2); ctx.fill();
}

// ===== ループ・UI =====
let last=performance.now(), acc=0;
function loop(now){
  const el=(now-last)/1000; last=now;
  if(!paused){ acc+=Math.min(el,0.12); const dt=model.sim.dt; while(acc>=dt){ step(); t+=dt; acc-=dt; } }
  draw(); requestAnimationFrame(loop);
}
function setStatus(s){ document.getElementById('status').textContent=s; }

async function loadUnifiedFromRepo(){
  try{
    const r=await fetch('要素数値情報.csv',{cache:'no-store'});
    if(!r.ok){ setStatus('要素数値情報.csv が見つかりません（リポジトリ直下に置いてください）'); return; }
    parseUnifiedCSV(await r.text());
  }catch(e){ console.error(e); setStatus('読込エラー: '+e.message); }
}
async function applyUnifiedFromLocal(){
  const f=document.getElementById('fileUnified').files[0];
  if(!f){ setStatus('CSVファイルを選択してください'); return; }
  parseUnifiedCSV(await f.text());
}
function togglePause(){ paused=!paused; document.getElementById('pause').textContent=paused?'再開':'一時停止'; }
function doReset(){
  // CSV 読込済み幾何から再配置：返し中央・棚高さに揃える
  const ha=model.anchors.HOIST_ANCHOR;
  xt=ha.x; vt=0; psi=0; wF=0; vFx=0; vFy=0;
  xF=model.anchors.FRAME_COM.x; yF=model.anchors.FRAME_COM.y;

  buildArmsAndSurfaces();
  const lipXs = lips.map(seg=>seg.p0.x);
  const lipL = Math.min(...lipXs), lipR = Math.max(...lipXs);
  const shelfY = shelves.reduce((s,seg)=> s + ((seg.p0.y+seg.p1.y)/2), 0) / shelves.length;

  cx = (lipL + lipR)/2;
  cy = shelfY - (model.cab.H/2 - model.cab.notch);
  phi=0; omega=0; cvx=0; cvy=0;

  solveChainPosition(6);
  t=0; paused=false; document.getElementById('pause').textContent='一時停止';
  setStatus('リセットしました（返し中央・棚高さに再整列）');
}
document.getElementById('loadUnified').onclick=loadUnifiedFromRepo;
document.getElementById('applyUnified').onclick=applyUnifiedFromLocal;
document.getElementById('pause').onclick=togglePause;
document.getElementById('reset').onclick=doReset;

// ===== 起動：CSVを自動読込してスタート =====
requestAnimationFrame(loop);
window.addEventListener('load', loadUnifiedFromRepo);
</script>
</body>
</html>
