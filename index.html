<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DXF レイヤビューア（静的表示 / mm / Y上＋）</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect width="64" height="64" rx="10" fill="%2310214a"/><path d="M10 46 L32 18 L54 46" stroke="%23ffd24d" stroke-width="6" fill="none"/></svg>'>
<style>
:root{
  --bg:#0b1020; --panel:#121a33; --fg:#e8eef9; --muted:#9fb3d9; --accent:#3a76ff;
  --grid:#1b2445; --axis:#2f8bff; --select:#ffd24d;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Meiryo,sans-serif}
.wrap{display:grid; grid-template-columns:360px 1fr; gap:12px; padding:12px; height:100%}
.card{background:var(--panel); border-radius:14px; box-shadow:0 10px 28px rgba(0,0,0,.35); overflow:hidden}
.panel{padding:14px; display:flex; flex-direction:column; gap:10px}
h1{font-size:18px; margin:0 0 6px}
h2{font-size:13px; color:var(--muted); margin:10px 0 6px}
.row{display:flex; gap:8px; align-items:center}
.row label{min-width:88px; font-size:12px; color:var(--muted)}
input[type=text]{flex:1; background:#0f1730; color:var(--fg); border:1px solid #24305a; border-radius:10px; padding:8px}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9); border:none; color:#fff; border-radius:10px; padding:8px 12px; cursor:pointer; font-weight:600}
.btn.ghost{background:#0f1730; border:1px solid #2a3a6a; color:var(--fg)}
.kbd{display:inline-block; padding:2px 6px; border:1px solid #2a3a6a; border-radius:8px; color:var(--muted); font-size:12px}
.small{font-size:12px; color:var(--muted)}
.layer{display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:8px}
.sw{width:14px; height:14px; border-radius:4px; border:1px solid #0006}
hr{border:none; height:1px; background:#1c2343; margin:6px 0}
canvas{width:100%; height:100%; display:block; cursor:grab}
canvas:active{cursor:grabbing}
.legend{font-size:12px; color:var(--muted)}
.badge{background:#10214a; color:#9fb3d9; border:1px solid #213064; padding:2px 6px; border-radius:10px; font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>DXF レイヤビューア</h1>
      <div class="legend">
        単位＝mm、座標系＝X右＋ / Y上＋。物理シミュレーションなし（純表示）。<br>
        <span class="badge">操作</span> マウス左ドラッグ＝パン、<span class="kbd">ホイール</span>＝ズーム、<span class="kbd">F</span>＝フィット、<span class="kbd">R</span>＝初期表示。
      </div>
    </div>

    <h2>読込</h2>
    <div class="row">
      <label>GitHub内</label>
      <input id="path" type="text" value="位置関係整理ファイル.dxf" />
      <button id="load" class="btn">読み込み</button>
    </div>
    <div class="row">
      <label>ローカル</label>
      <input id="file" type="file" accept=".dxf" />
      <button id="fit" class="btn ghost">フィット</button>
      <button id="reset" class="btn ghost">R</button>
    </div>

    <h2>レイヤ</h2>
    <div id="layers"></div>

    <h2>表示</h2>
    <div class="row"><label>グリッド</label><input id="grid" type="checkbox" checked /><span class="small">間隔 200mm</span></div>
    <div class="row"><label>原点/軸</label><input id="axes" type="checkbox" checked /></div>
    <div class="row"><label>注釈文字</label><input id="showtext" type="checkbox" checked /></div>

    <hr>
    <div id="info" class="small">未読込</div>
  </div>

  <div class="card"><canvas id="cv"></canvas></div>
</div>

<script>
// ====== Canvas ======
const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1);
let ready=false;  // ← 初期化完了フラグ
function resize(){
  const r=cv.getBoundingClientRect();
  const w=Math.max(2,Math.floor(r.width*DPR)), h=Math.max(2,Math.floor(r.height*DPR));
  if(cv.width!==w || cv.height!==h){ cv.width=w; cv.height=h; }
  if(ready) draw();             // ← 変数初期化前は draw しない
}
window.addEventListener('resize',resize);

// ====== 簡易 DXF パーサ ======
function aciColor(n){
  const table={0:"#cccccc",1:"#ff0000",2:"#ffff00",3:"#00ff00",4:"#00ffff",5:"#0000ff",6:"#ff00ff",7:"#ffffff",8:"#808080",9:"#808080"};
  if(table[n]) return table[n];
  const h=(n%64)/64, s=0.7, v=0.95; const i=Math.floor(h*6), f=h*6-i;
  const p=v*(1-s), q=v*(1-s*f), t=v*(1-s*(1-f));
  const [r,g,b]=[[v,t,p],[q,v,p],[p,v,t],[p,q,v],[t,p,v],[v,p,q]][i%6].map(x=>Math.round(x*255));
  return `rgb(${r},${g},${b})`;
}
function parseDXF(text){
  const lines=text.split(/\r\n|\r|\n/); let i=0, N=lines.length;
  const next=()=>{ if(i+1>=N) return null; const code=parseInt(lines[i++].trim(),10); const val=(lines[i++]??"").trim(); return {code,val}; };
  const layerColor={}, ents=[];
  while(true){
    const p=next(); if(!p) break;
    if(p.code===0 && p.val==="SECTION"){
      let name=""; let q;
      while((q=next())){ if(q.code===2){ name=q.val; break; } if(q.code===0){ i-=2; break; } }
      if(name==="TABLES"){
        while((q=next())){ if(q.code===0&&q.val==="ENDSEC") break;
          if(q.code===0&&q.val==="TABLE"){
            let tname=""; let r; while((r=next())){ if(r.code===2){ tname=r.val; break; } }
            if(tname==="LAYER"){
              while((r=next())){ if(r.code===0&&r.val==="ENDTAB") break;
                if(r.code===0&&r.val==="LAYER"){
                  let nm="", col=7, s;
                  while((s=next())){ if(s.code===2) nm=s.val; else if(s.code===62) col=parseInt(s.val,10); else if(s.code===0){ i-=2; break; } }
                  if(nm) layerColor[nm]=col;
                }
              }
            } else { while((r=next())){ if(r.code===0&&r.val==="ENDTAB") break; } }
          }
        }
      } else if(name==="ENTITIES"){
        while((q=next())){ if(!q) break; if(q.code===0&&q.val==="ENDSEC") break;
          if(q.code!==0) continue;
          const type=q.val; const data=[]; let r;
          while((r=next())){ if(r.code===0){ i-=2; break; } data.push(r); }
          const by=(c)=>data.filter(p=>p.code===c).map(p=>p.val);
          const layer=(by(8)[0]||"0"); const colorIdx=(by(62)[0]!==undefined)?parseInt(by(62)[0],10):undefined;
          if(type==="LINE"){
            ents.push({type:"line",layer,colorIdx,x1:+by(10)[0],y1:+by(20)[0],x2:+by(11)[0],y2:+by(21)[0]});
          } else if(type==="LWPOLYLINE"){
            const xs=by(10).map(Number), ys=by(20).map(Number);
            const closed=(parseInt(by(70)[0]||"0",10)&1)===1;
            const pts=xs.map((x,k)=>({x, y:ys[k]}));
            ents.push({type:"polyline",layer,colorIdx,pts,closed});
          } else if(type==="CIRCLE"){
            ents.push({type:"circle",layer,colorIdx,cx:+by(10)[0],cy:+by(20)[0],r:+by(40)[0]});
          } else if(type==="ARC"){
            ents.push({type:"arc",layer,colorIdx,cx:+by(10)[0],cy:+by(20)[0],r:+by(40)[0],a0:(+by(50)[0]||0)*Math.PI/180,a1:(+by(51)[0]||0)*Math.PI/180});
          } else if(type==="TEXT"||type==="MTEXT"){
            const x=+by(10)[0], y=+by(20)[0]; const h=+(by(40)[0]||by(42)[0]||"40");
            let s=by(1).concat(by(3)).concat(by(4)).join("").replace(/\\P/g,"\n");
            ents.push({type:"text",layer,colorIdx,x,y,h,text:s});
          }
        }
      } else { while(true){ const q2=next(); if(!q2) break; if(q2.code===0&&q2.val==="ENDSEC") break; } }
    }
  }
  const layers=[...new Set(ents.map(e=>e.layer))].sort();
  const colors={}; layers.forEach(n=>{ const aci=(layerColor[n]!==undefined)?layerColor[n]:7; colors[n]=aciColor(aci); });
  return {entities:ents,layers,colors};
}

// ====== Viewer state（← ここを draw より前に定義） ======
let model=null;                 // {entities,layers,colors}
let showLayer={};               // layerName -> boolean
let showGrid=true, showAxes=true, showText=true;

let s=0.25;                     // pixel / mm
let ox=0, oy=0;                 // 画面座標の原点補正
let worldBBox=null;             // {minx,miny,maxx,maxy}

// ====== Viewer helpers ======
function fitToView(){
  if(!model || !model.entities.length) return;
  const m=worldBBox;
  const W=cv.width, H=cv.height;
  const margin=60;
  const sx=(W-2*margin)/(m.maxx-m.minx||1);
  const sy=(H-2*margin)/(m.maxy-m.miny||1);
  s=Math.max(0.1, Math.min(sx, sy));
  const cx=(m.minx+m.maxx)/2, cy=(m.miny+m.maxy)/2;
  ox = W/2 - cx*s;
  oy = H/2 + cy*s;
  draw();
}
function resetView(){ s=0.25; ox=cv.width*0.5; oy=cv.height*0.6; draw(); }
function sx_(x){ return ox + x*s; }
function sy_(y){ return oy - y*s; }  // Y上＋ → Canvas下＋反転
function computeBBox(){
  if(!model) return null;
  let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
  const upd=(x,y)=>{ if(x<minx)minx=x; if(x>maxx)maxx=x; if(y<miny)miny=y; if(y>maxy)maxy=y; };
  for(const e of model.entities){
    if(e.type==="line"){ upd(e.x1,e.y1); upd(e.x2,e.y2); }
    else if(e.type==="polyline"){ e.pts.forEach(p=>upd(p.x,p.y)); }
    else if(e.type==="circle"||e.type==="arc"){ upd(e.cx-e.r,e.cy-e.r); upd(e.cx+e.r,e.cy+e.r); }
    else if(e.type==="text"){ upd(e.x,e.y); }
  }
  if(!isFinite(minx)){ minx=-1000; maxx=1000; miny=-1000; maxy=1000; }
  worldBBox={minx,miny,maxx,maxy};
}
function drawGrid(){
  const step=200;
  const m=worldBBox||{minx:-4000,maxx:4000,miny:-2500,maxy:2500};
  const gx0=Math.floor(m.minx/step)*step, gx1=Math.ceil(m.maxx/step)*step;
  const gy0=Math.floor(m.miny/step)*step, gy1=Math.ceil(m.maxy/step)*step;
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); ctx.lineWidth=1;
  for(let x=gx0;x<=gx1;x+=step){ ctx.beginPath(); ctx.moveTo(sx_(x), sy_(gy0)); ctx.lineTo(sx_(x), sy_(gy1)); ctx.stroke(); }
  for(let y=gy0;y<=gy1;y+=step){ ctx.beginPath(); ctx.moveTo(sx_(gx0), sy_(y)); ctx.lineTo(sx_(gx1), sy_(y)); ctx.stroke(); }
}
function drawAxes(){
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axis'); ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(sx_(0), sy_(-10000)); ctx.lineTo(sx_(0), sy_(10000)); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx_(-10000), sy_(0)); ctx.lineTo(sx_(10000), sy_(0)); ctx.stroke();
  ctx.fillStyle="#ffffff"; ctx.beginPath(); ctx.arc(sx_(0), sy_(0), 4, 0, Math.PI*2); ctx.fill();
}
function draw(){
  const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);
  if(showGrid) drawGrid();
  if(showAxes) drawAxes();
  if(!model) return;

  for(const e of model.entities){
    if(showLayer[e.layer]===false) continue;
    const col = model.colors[e.layer]||"#ffffff";
    ctx.strokeStyle=col; ctx.fillStyle=col; ctx.lineWidth=2;

    if(e.type==="line"){
      ctx.beginPath(); ctx.moveTo(sx_(e.x1), sy_(e.y1)); ctx.lineTo(sx_(e.x2), sy_(e.y2)); ctx.stroke();
    } else if(e.type==="polyline"){
      if(e.pts.length<2) continue;
      ctx.beginPath(); ctx.moveTo(sx_(e.pts[0].x), sy_(e.pts[0].y));
      for(let k=1;k<e.pts.length;k++) ctx.lineTo(sx_(e.pts[k].x), sy_(e.pts[k].y));
      if(e.closed) ctx.closePath();
      ctx.stroke();
    } else if(e.type==="circle"){
      ctx.beginPath(); ctx.arc(sx_(e.cx), sy_(e.cy), e.r*s, 0, Math.PI*2); ctx.stroke();
    } else if(e.type==="arc"){
      ctx.beginPath(); ctx.arc(sx_(e.cx), sy_(e.cy), e.r*s, -e.a0, -e.a1, true); ctx.stroke();
    } else if(e.type==="text" && showText){
      ctx.font = `${Math.max(10, e.h*s)}px ui-sans-serif`;
      ctx.fillStyle=col;
      const lines = String(e.text||"").split(/\r?\n/);
      lines.forEach((ln, idx)=> ctx.fillText(ln, sx_(e.x), sy_(e.y) + idx*e.h*s));
    }
  }
}

// ====== レイヤ UI ======
const layersDiv=document.getElementById('layers');
function buildLayerUI(){
  layersDiv.innerHTML="";
  if(!model){ layersDiv.textContent="未読込"; return; }
  model.layers.forEach(name=>{
    const wrap=document.createElement('div'); wrap.className='layer';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=(showLayer[name]!==false);
    cb.onchange=()=>{ showLayer[name]=cb.checked; draw(); };
    const sw=document.createElement('div'); sw.className='sw'; sw.style.background=model.colors[name];
    const lab=document.createElement('span'); lab.textContent=name;
    wrap.append(cb, sw, lab); layersDiv.appendChild(wrap);
  });
}

// ====== 入出力・イベント ======
async function loadFromPath(p){
  const url=encodeURI(p);
  const res=await fetch(url);
  if(!res.ok) throw new Error(`fetch失敗: ${res.status} ${res.statusText} (${url})`);
  const text=await res.text();
  model=parseDXF(text);
  computeBBox(); fitToView(); buildLayerUI();
  info(`${model.layers.length} レイヤ / ${model.entities.length} エンティティ`);
}
function info(s){ document.getElementById('info').textContent=s; }

document.getElementById('load').onclick=async()=>{
  try{ await loadFromPath(document.getElementById('path').value.trim()); }
  catch(e){ console.error(e); info(`読込エラー: ${e.message}`); }
};
document.getElementById('file').onchange=async(e)=>{
  const f=e.target.files[0]; if(!f) return;
  const text=await f.text();
  model=parseDXF(text); computeBBox(); fitToView(); buildLayerUI();
  info(`ローカル読込: ${f.name} / ${model.layers.length} レイヤ / ${model.entities.length} 件`);
};
document.getElementById('fit').onclick=()=>fitToView();
document.getElementById('reset').onclick=()=>{ resetView(); };

document.getElementById('grid').onchange=(e)=>{ showGrid=e.target.checked; draw(); };
document.getElementById('axes').onchange=(e)=>{ showAxes=e.target.checked; draw(); };
document.getElementById('showtext').onchange=(e)=>{ showText=e.target.checked; draw(); };

// パン/ズーム
let dragging=false, lastX=0, lastY=0;
cv.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY;});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  ox+=dx; oy+=dy; draw();
});
cv.addEventListener('wheel',e=>{
  e.preventDefault();
  const k=Math.exp(-e.deltaY*0.0015);
  const mx=e.offsetX*DPR, my=e.offsetY*DPR;
  const wx=(mx-ox)/s, wy=(my-oy)/s;
  s=Math.max(0.02, Math.min(5, s*k));
  ox = mx - wx*s; oy = my - wy*s;
  draw();
},{passive:false});

// ショートカット
window.addEventListener('keydown',e=>{
  if(e.key==='f' || e.key==='F'){ fitToView(); }
  if(e.key==='r' || e.key==='R'){ resetView(); }
});

// ==== 初期化：ここで初めて resize/draw を許可 ====
ready=true;
resize();                    // ← キャンバス採寸
draw();                      // ← 空画面でも描画
// 既定パス自動読み込み
loadFromPath(document.getElementById('path').value.trim())
  .catch(e=>{ console.warn(e); info('既定DXFは未配置か、パスが違います。左上の欄でパスを指定して「読み込み」。'); });
</script>
</body>
</html>
