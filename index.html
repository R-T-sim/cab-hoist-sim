<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DXF レイヤビューア（静的表示 / mm / Y上＋）</title>
<style>
:root{
  --bg:#0b1020; --panel:#121a33; --fg:#e8eef9; --muted:#9fb3d9; --accent:#3a76ff;
  --grid:#1b2445; --axis:#2f8bff; --select:#ffd24d;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Meiryo,sans-serif}
.wrap{display:grid; grid-template-columns:360px 1fr; gap:12px; padding:12px; height:100%}
.card{background:var(--panel); border-radius:14px; box-shadow:0 10px 28px rgba(0,0,0,.35); overflow:hidden}
.panel{padding:14px; display:flex; flex-direction:column; gap:10px}
h1{font-size:18px; margin:0 0 6px}
h2{font-size:13px; color:var(--muted); margin:10px 0 6px}
.row{display:flex; gap:8px; align-items:center}
.row label{min-width:88px; font-size:12px; color:var(--muted)}
input[type=text]{flex:1; background:#0f1730; color:var(--fg); border:1px solid #24305a; border-radius:10px; padding:8px}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9); border:none; color:#fff; border-radius:10px; padding:8px 12px; cursor:pointer; font-weight:600}
.btn.ghost{background:#0f1730; border:1px solid #2a3a6a; color:var(--fg)}
.kbd{display:inline-block; padding:2px 6px; border:1px solid #2a3a6a; border-radius:8px; color:var(--muted); font-size:12px}
.small{font-size:12px; color:var(--muted)}
.layer{display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:8px}
.sw{width:14px; height:14px; border-radius:4px; border:1px solid #0006}
hr{border:none; height:1px; background:#1c2343; margin:6px 0}
canvas{width:100%; height:100%; display:block; cursor:grab}
canvas:active{cursor:grabbing}
.legend{font-size:12px; color:var(--muted)}
.badge{background:#10214a; color:#9fb3d9; border:1px solid #213064; padding:2px 6px; border-radius:10px; font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>DXF レイヤビューア</h1>
      <div class="legend">
        単位＝mm、座標系＝X右＋ / Y上＋。物理シミュレーションなし（純粋な図面表示）。<br>
        <span class="badge">操作</span>  マウス左ドラッグ＝パン、<span class="kbd">ホイール</span>＝ズーム、<span class="kbd">F</span>＝フィット、<span class="kbd">R</span>＝初期表示。 
      </div>
    </div>

    <h2>読込</h2>
    <div class="row">
      <label>GitHub内</label>
      <input id="path" type="text" value="位置関係整理ファイル.dxf" />
      <button id="load" class="btn">読み込み</button>
    </div>
    <div class="row">
      <label>ローカル</label>
      <input id="file" type="file" accept=".dxf" />
      <button id="fit" class="btn ghost">フィット</button>
      <button id="reset" class="btn ghost">R</button>
    </div>

    <h2>レイヤ</h2>
    <div id="layers"></div>

    <h2>表示</h2>
    <div class="row"><label>グリッド</label><input id="grid" type="checkbox" checked /><span class="small">間隔 200mm</span></div>
    <div class="row"><label>原点/軸</label><input id="axes" type="checkbox" checked /></div>
    <div class="row"><label>注釈文字</label><input id="showtext" type="checkbox" checked /></div>

    <hr>
    <div id="info" class="small">未読込</div>
  </div>

  <div class="card"><canvas id="cv"></canvas></div>
</div>

<script>
// ====== 低依存の簡易 DXF パーサ（LINE/LWPOLYLINE/POLYLINE+VERTEX/CIRCLE/ARC/TEXT 対応） ======
function aciColor(n){ // AutoCAD ACI の代表色（簡易）
  const table={0:"#cccccc",1:"#ff0000",2:"#ffff00",3:"#00ff00",4:"#00ffff",5:"#0000ff",6:"#ff00ff",7:"#ffffff",8:"#808080",9:"#808080"};
  if(table[n]) return table[n];
  // 10〜255 は HSV 風に適当配色
  const h=(n%64)/64, s=0.7, v=0.95; const i=Math.floor(h*6); const f=h*6-i;
  const p=v*(1-s), q=v*(1-s*f), t=v*(1-s*(1-f));
  const [r,g,b]=[
    [v,t,p],[q,v,p],[p,v,t],[p,q,v],[t,p,v],[v,p,q]
  ][i%6].map(x=>Math.round(x*255));
  return `rgb(${r},${g},${b})`;
}

function parseDXF(text){
  const lines=text.split(/\r\n|\r|\n/);
  let i=0; const N=lines.length;
  const next=()=>{ if(i+1>=N) return null; const code=parseInt(lines[i++].trim(),10); const val=(lines[i++]??"").trim(); return {code,val}; };

  // layer color table
  const layerColor={}; // name -> color index (ACI)
  // entities
  const ents=[];       // {type, layer, ...}
  // pass
  while(true){
    const p=next(); if(!p) break;
    if(p.code===0 && p.val==="SECTION"){
      const name = (()=>{ let q; while((q=next())){ if(q.code===2) return q.val; if(q.code===0) { i-=2; return ""; } } })();
      if(name==="TABLES"){
        // parse TABLES
        while(true){
          const q=next(); if(!q) break;
          if(q.code===0 && q.val==="ENDSEC") break;
          if(q.code===0 && q.val==="TABLE"){
            let tname=""; let r;
            while((r=next())){ if(r.code===2){ tname=r.val; break; } }
            if(tname==="LAYER"){
              // inside LAYER table until ENDTAB
              while((r=next())){
                if(r.code===0 && r.val==="ENDTAB") break;
                if(r.code===0 && r.val==="LAYER"){
                  let name="", col=7;
                  while((r=next())){
                    if(r.code===2) name=r.val;
                    else if(r.code===62) col=parseInt(r.val,10);
                    else if(r.code===0){ i-=2; break; }
                  }
                  if(name) layerColor[name]=col;
                }
              }
            }else{
              // skip other table
              while((r=next())){ if(r.code===0 && r.val==="ENDTAB") break; }
            }
          }
        }
      } else if(name==="ENTITIES"){
        // parse ENTITIES
        while(true){
          const q=next(); if(!q) break;
          if(q.code===0 && q.val==="ENDSEC") break;
          if(q.code!==0){ continue; }
          const type=q.val;
          // collect entity group pairs until next 0 or ENDSEC
          const data=[]; let r;
          while((r=next())){ if(r.code===0){ i-=2; break; } data.push(r); }
          const byCode=(c)=>data.filter(p=>p.code===c).map(p=>p.val);
          const layer=(byCode(8)[0]||"0");
          const colorIdx=(byCode(62)[0]!==undefined)?parseInt(byCode(62)[0],10):undefined;

          if(type==="LINE"){
            const x1=+byCode(10)[0], y1=+byCode(20)[0];
            const x2=+byCode(11)[0], y2=+byCode(21)[0];
            ents.push({type:"line",layer,colorIdx,x1,y1,x2,y2});
          } else if(type==="LWPOLYLINE"){
            const xs=byCode(10).map(Number), ys=byCode(20).map(Number);
            const closed = (parseInt(byCode(70)[0]||"0",10) & 1)===1;
            const pts=xs.map((x,k)=>({x, y:ys[k]}));
            ents.push({type:"polyline",layer,colorIdx,pts,closed});
          } else if(type==="POLYLINE"){
            // gather following VERTEX until SEQEND already folded by our collector → data includes only header.
            // In some DXFs POLYLINE is followed in ENTITIES stream; our simple collector misses VERTEX.
            // Fall back: ignore; most modern DXFs use LWPOLYLINE.
          } else if(type==="CIRCLE"){
            const cx=+byCode(10)[0], cy=+byCode(20)[0], r=+byCode(40)[0];
            ents.push({type:"circle",layer,colorIdx,cx,cy,r});
          } else if(type==="ARC"){
            const cx=+byCode(10)[0], cy=+byCode(20)[0], r=+byCode(40)[0];
            const a0=(+byCode(50)[0]||0)*Math.PI/180, a1=(+byCode(51)[0]||0)*Math.PI/180;
            ents.push({type:"arc",layer,colorIdx,cx,cy,r,a0,a1});
          } else if(type==="TEXT" || type==="MTEXT"){
            const x=+byCode(10)[0], y=+byCode(20)[0];
            const h=+(byCode(40)[0]||byCode(42)[0]||"40");
            // TEXT: 1 は文字。MTEXT: 1 or 3 or 4 に分割文字列
            let s = byCode(1).concat(byCode(3)).concat(byCode(4)).join("");
            s = s.replace(/\\P/g,"\n");
            ents.push({type:"text",layer,colorIdx,x,y,h,text:s});
          } else {
            // unsupported -> ignore quietly
          }
        }
      } else {
        // skip other SECTIONs
        while(true){ const q=next(); if(!q) break; if(q.code===0 && q.val==="ENDSEC") break; }
      }
    }
  }
  // build layers list
  const layers=[...new Set(ents.map(e=>e.layer))].sort();
  const colors={};
  layers.forEach(n=>{
    const aci = (layerColor[n]!==undefined)?layerColor[n]:7;
    colors[n] = aciColor(aci);
  });
  return {entities:ents, layers, colors};
}

// ====== ビューア ======
const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1);
function resize(){const r=cv.getBoundingClientRect(); const w=Math.max(2,Math.floor(r.width*DPR)), h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h; draw();}}
window.addEventListener('resize',resize); resize();

let model=null;        // {entities, layers, colors}
let showLayer={};      // layerName -> boolean
let showGrid=true, showAxes=true, showText=true;

let s=0.25;            // pixel per mm（初期）
let ox=0, oy=0;        // 画面中心に対するワールド原点オフセット [px]
let worldBBox=null;    // {minx,miny,maxx,maxy}

function fitToView(){
  if(!model || !model.entities.length) return;
  const m=worldBBox;
  const W=cv.width, H=cv.height;
  const margin=60;
  const sx=(W-2*margin)/(m.maxx-m.minx||1);
  const sy=(H-2*margin)/(m.maxy-m.miny||1);
  s=Math.max(0.1, Math.min(sx, sy));
  // 中心合わせ
  const cx=(m.minx+m.maxx)/2, cy=(m.miny+m.maxy)/2;
  ox = W/2 - cx*s;
  oy = H/2 + cy*s;
  draw();
}
function resetView(){ s=0.25; ox=cv.width*0.5; oy=cv.height*0.6; draw(); }

function sx_(x){ return ox + x*s;}
function sy_(y){ return oy - y*s;} // Y上＋ → Canvas 下＋を反転

function computeBBox(){
  if(!model) return null;
  let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
  const upd=(x,y)=>{ if(x<minx)minx=x; if(x>maxx)maxx=x; if(y<miny)miny=y; if(y>maxy)maxy=y; };
  for(const e of model.entities){
    if(e.type==="line"){ upd(e.x1,e.y1); upd(e.x2,e.y2); }
    else if(e.type==="polyline"){ e.pts.forEach(p=>upd(p.x,p.y)); }
    else if(e.type==="circle"||e.type==="arc"){ upd(e.cx-e.r,e.cy-e.r); upd(e.cx+e.r,e.cy+e.r); }
    else if(e.type==="text"){ upd(e.x,e.y); }
  }
  if(!isFinite(minx)){ minx=-1000; maxx=1000; miny=-1000; maxy=1000; }
  worldBBox={minx,miny,maxx,maxy};
}

function drawGrid(){
  const step=200; // mm
  const m=worldBBox||{minx:-4000,maxx:4000,miny:-2500,maxy:2500};
  const gminx=Math.floor(m.minx/step)*step, gmaxx=Math.ceil(m.maxx/step)*step;
  const gminy=Math.floor(m.miny/step)*step, gmaxy=Math.ceil(m.maxy/step)*step;
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); ctx.lineWidth=1;
  for(let x=gminx; x<=gmaxx; x+=step){ ctx.beginPath(); ctx.moveTo(sx_(x), sy_(gminy)); ctx.lineTo(sx_(x), sy_(gmaxy)); ctx.stroke(); }
  for(let y=gminy; y<=gmaxy; y+=step){ ctx.beginPath(); ctx.moveTo(sx_(gminx), sy_(y)); ctx.lineTo(sx_(gmaxx), sy_(y)); ctx.stroke(); }
}

function drawAxes(){
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--axis'); ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(sx_(0), sy_(-10000)); ctx.lineTo(sx_(0), sy_(10000)); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx_(-10000), sy_(0)); ctx.lineTo(sx_(10000), sy_(0)); ctx.stroke();
  // 原点
  ctx.fillStyle="#ffffff"; ctx.beginPath(); ctx.arc(sx_(0), sy_(0), 4, 0, Math.PI*2); ctx.fill();
}

function draw(){
  const W=cv.width, H=cv.height;
  ctx.clearRect(0,0,W,H);
  if(showGrid) drawGrid();
  if(showAxes) drawAxes();
  if(!model) return;

  for(const e of model.entities){
    if(showLayer[e.layer]===false) continue;
    const col = model.colors[e.layer]||"#ffffff";
    ctx.strokeStyle=col; ctx.fillStyle=col; ctx.lineWidth=2;

    if(e.type==="line"){
      ctx.beginPath(); ctx.moveTo(sx_(e.x1), sy_(e.y1)); ctx.lineTo(sx_(e.x2), sy_(e.y2)); ctx.stroke();
    }
    else if(e.type==="polyline"){
      if(e.pts.length<2) continue;
      ctx.beginPath(); ctx.moveTo(sx_(e.pts[0].x), sy_(e.pts[0].y));
      for(let k=1;k<e.pts.length;k++) ctx.lineTo(sx_(e.pts[k].x), sy_(e.pts[k].y));
      if(e.closed) ctx.closePath();
      ctx.stroke();
    }
    else if(e.type==="circle"){
      ctx.beginPath(); ctx.arc(sx_(e.cx), sy_(e.cy), e.r*s, 0, Math.PI*2); ctx.stroke();
    }
    else if(e.type==="arc"){
      ctx.beginPath(); ctx.arc(sx_(e.cx), sy_(e.cy), e.r*s, -e.a0, -e.a1, true); // Y反転のため符号反転
      ctx.stroke();
    }
    else if(e.type==="text" && showText){
      ctx.font = `${Math.max(10, e.h*s)}px ui-sans-serif`;
      ctx.fillStyle=col;
      const lines = String(e.text||"").split(/\r?\n/);
      lines.forEach((ln, idx)=> ctx.fillText(ln, sx_(e.x), sy_(e.y) + idx*e.h*s));
    }
  }
}

// ====== レイヤ UI ======
const layersDiv=document.getElementById('layers');
function buildLayerUI(){
  layersDiv.innerHTML="";
  if(!model){ layersDiv.textContent="未読込"; return; }
  model.layers.forEach(name=>{
    const wrap=document.createElement('div'); wrap.className='layer';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=(showLayer[name]!==false);
    cb.onchange=()=>{ showLayer[name]=cb.checked; draw(); };
    const sw=document.createElement('div'); sw.className='sw'; sw.style.background=model.colors[name];
    const lab=document.createElement('span'); lab.textContent=name;
    wrap.append(cb, sw, lab); layersDiv.appendChild(wrap);
  });
}

// ====== 入出力・イベント ======
async function loadFromPath(p){
  const url=encodeURI(p);
  const res=await fetch(url);
  if(!res.ok) throw new Error(`fetch失敗: ${res.status} ${res.statusText}`);
  const text=await res.text();
  model=parseDXF(text);
  computeBBox(); fitToView(); buildLayerUI();
  info(`${model.layers.length} レイヤ / ${model.entities.length} エンティティ`);
}
function info(s){ document.getElementById('info').textContent=s; }

document.getElementById('load').onclick=async()=>{
  try{ await loadFromPath(document.getElementById('path').value.trim()); }
  catch(e){ console.error(e); info(`読込エラー: ${e.message}`); }
};
document.getElementById('file').onchange=async(e)=>{
  const f=e.target.files[0]; if(!f) return;
  const text=await f.text();
  model=parseDXF(text); computeBBox(); fitToView(); buildLayerUI();
  info(`ローカル読込: ${f.name} / ${model.layers.length} レイヤ / ${model.entities.length} 件`);
};
document.getElementById('fit').onclick=()=>fitToView();
document.getElementById('reset').onclick=()=>{ resetView(); };

document.getElementById('grid').onchange=(e)=>{ showGrid=e.target.checked; draw(); };
document.getElementById('axes').onchange=(e)=>{ showAxes=e.target.checked; draw(); };
document.getElementById('showtext').onchange=(e)=>{ showText=e.target.checked; draw(); };

// パン/ズーム
let dragging=false, lastX=0, lastY=0;
cv.addEventListener('mousedown',e=>{dragging=true; lastX=e.clientX; lastY=e.clientY;});
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  ox+=dx; oy+=dy; draw();
});
cv.addEventListener('wheel',e=>{
  e.preventDefault();
  const k=Math.exp(-e.deltaY*0.0015);
  // ズームの中心をマウス位置に合わせる
  const mx=e.offsetX*DPR, my=e.offsetY*DPR;
  const wx=(mx-ox)/s, wy=(my-oy)/s;
  s=Math.max(0.02, Math.min(5, s*k));
  ox = mx - wx*s; oy = my - wy*s;
  draw();
},{passive:false});

// ショートカット
window.addEventListener('keydown',e=>{
  if(e.key==='f' || e.key==='F'){ fitToView(); }
  if(e.key==='r' || e.key==='R'){ resetView(); }
});

// 初期：既定パスを試す
(async()=>{
  try{ await loadFromPath(document.getElementById('path').value.trim()); }
  catch(e){ info('既定ファイルはまだ見つかりません。左の「読込」からDXFを指定してください。'); draw(); }
})();
</script>
</body>
</html>
