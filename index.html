<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CAB 2D（要素数値情報.csv 1枚 / mm / Y上＋）</title>
<style>
:root{--bg:#0b1020;--fg:#e8eef9;--muted:#9fb3d9;--card:#121a33;--good:#26d07c;--arm:#ff5a5a;--cab:#7fb6ff}
html,body{height:100%}body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
.wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%;padding:14px;box-sizing:border-box}
.card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.panel{padding:14px;display:flex;flex-direction:column;gap:10px}
h1{font-size:18px;margin:0 0 6px}h2{font-size:13px;margin:8px 0 2px;color:var(--muted);font-weight:600}
.row{display:flex;align-items:center;gap:10px}.row label{min-width:150px;font-size:12px;color:var(--muted)}
.btn{background:linear-gradient(180deg,#3a76ff,#2b59d9);border:none;color:#fff;border-radius:12px;padding:9px 12px;cursor:pointer;font-weight:600}
.btn.secondary{background:#19254a;color:var(--fg);border:1px solid #2a3a6a}
.legend{font-size:12px;color:var(--muted)}canvas{width:100%;height:100%;display:block}
hr{border:none;height:1px;background:#1b2445;margin:8px 0}
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card panel">
    <div>
      <h1>ホイスト（緑）＋ 吊具天秤＆アーム（赤）＋ CAB（青）</h1>
      <div class="legend">
        入力：<b>要素数値情報.csv</b>（1枚）／ 単位：mm（Y上＋）／ チェーンは剛体長。<br>
        ← / →：台車加減速（|v|≤0.3 m/s）、Space：ブレーキ、P：一時停止、R：リセット。
      </div>
    </div>

    <h2>CSV 読み込み</h2>
    <div class="row"><label>リポジトリ直下</label><button class="btn" id="loadUnified">1枚CSVを読み込み</button></div>
    <div class="row"><label>ローカル選択</label><input id="fileUnified" type="file" accept=".csv"><button class="btn secondary" id="applyUnified">反映</button></div>

    <h2>操作</h2>
    <div class="row" style="gap:12px;flex-wrap:wrap">
      <button class="btn secondary" id="pause">一時停止</button>
      <button class="btn secondary" id="reset">リセット</button>
    </div>

    <hr/>
    <div class="legend" id="status">未読込</div>
    <div class="small">デバッグ点：HOISTアンカー / 天秤COM / アーム支点 / CAB重心</div>
  </div>

  <div class="card" style="position:relative;overflow:hidden"><canvas id="cv"></canvas></div>
</div>

<script>
// ===== 基本ユーティリティ =====
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const DPR=Math.max(1,window.devicePixelRatio||1);
function resize(){const r=cv.getBoundingClientRect();const w=Math.max(2,Math.floor(r.width*DPR)),h=Math.max(2,Math.floor(r.height*DPR)); if(cv.width!==w||cv.height!==h){cv.width=w;cv.height=h;}}
window.addEventListener('resize',resize); resize();
function PPM(){const W=cv.width,H=cv.height;return Math.max(Math.min(W/6000,H/4200),0.08);}
function num(v){const n=parseFloat(String(v??'').replace(/[^\-+0-9.eE]/g,'')); return Number.isFinite(n)?n:0;}
function rot(a,v){const c=Math.cos(a),s=Math.sin(a);return {x:c*v.x - s*v.y, y:s*v.x + c*v.y};}
function add(a,b){return {x:a.x+b.x,y:a.y+b.y};}
function sub(a,b){return {x:a.x-b.x,y:a.y-b.y};}
function len(v){return Math.hypot(v.x,v.y);}
function I_rect(m,W,H){const w=W/1000,h=H/1000; return m*(w*w+h*h)/12;}

// ===== モデルと状態 =====
let model={
  anchors:{
    HOIST_ANCHOR:{x:0,y:0},    // チェーン/ホイスト交点（下辺中央）
    FRAME_COM:{x:0,y:-560},    // 天秤の重心（世界）
    CHAIN_A_LOCAL:{x:0,y:60},  // 天秤ローカルでのチェーン取付
    PIVOT_L_LOCAL:{x:-700,y:-620}, // 天秤ローカルでのアーム支点（※CSV読込で COM 基準へ変換）
    PIVOT_R_LOCAL:{x: 700,y:-620}
  },
  hoistRect:{Lh:400,Hh:200},
  beam:{mass:180, span:2340, height:120},
  chain:{L:500},
  arms:{
    L:{out:74, drop_out:190, drop_vert:350, shelf_in:85, lip_in:51, lip_up:39},
    R:{out:74, drop_out:190, drop_vert:350, shelf_in:85, lip_in:51, lip_up:39}
  },
  cab:{mass:400,W:1800,H:1200,cg:{x:7,y:-1800}, mu:0.30, cphi:10, notch:0},
  sim:{dt:1/600, g:9810}, // Y上＋ → 下向きは -g
  hoist:{a_cmd:3000, vmax:300, ccart:0.26}
};

// 状態（動）
let t=0, paused=false;
let xt=0, vt=0;                                // 台車 x（=ホイストアンカーx）
let xF=0, yF=-560, vFx=0, vFy=0, psi=0, wF=0; // 天秤 COM と角速度
let cx=7, cy=-1800, cvx=0, cvy=0, phi=0, omega=0; // CAB

function I_frame(){return I_rect(model.beam.mass, model.beam.span, model.beam.height);}
function I_cab(){return I_rect(model.cab.mass, model.cab.W, model.cab.H);}
function posF(local){return add({x:xF,y:yF}, rot(psi, local));}
function velAt(local){const r=rot(psi,local); return {x:vFx - wF*r.y, y:vFy + wF*r.x};}

// ===== アーム幾何（棚線分を天秤ローカル→世界に動的生成） =====
let shelvesWorld=[];  // [{x0,y0,x1,y1}] ×2
let armPolys={L:[],R:[]}, armRoots={L:{x:0,y:0}, R:{x:0,y:0}};
function buildArmsAndShelves(){
  shelvesWorld=[]; armPolys.L=[]; armPolys.R=[];
  const ex=rot(psi,{x:1,y:0}), ey=rot(psi,{x:0,y:1});

  function build(side){
    const prm=model.arms[side];
    const sgn = (side==='L')? -1 : +1;
    const pivotLocal = (side==='L')? model.anchors.PIVOT_L_LOCAL : model.anchors.PIVOT_R_LOCAL;
    let p = posF(pivotLocal); // 世界座標の支点
    armRoots[side]=p;
    const poly=[{x:p.x,y:p.y}];

    function step(dx,dy){
      p={x:p.x+ex.x*dx+ey.x*dy, y:p.y+ex.y*dx+ey.y*dy};
      poly.push({x:p.x,y:p.y}); return p;
    }
    // 外広がり→落とし→縦棒→受面→返し
    step(sgn*prm.out, -prm.drop_out);
    step(0, -prm.drop_vert);
    const shelfStart=step(-sgn*prm.shelf_in, 0);
    const shelfEnd  =step(-sgn*prm.lip_in,  prm.lip_up);

    shelvesWorld.push({x0:shelfStart.x,y0:shelfStart.y,x1:shelfEnd.x,y1:shelfEnd.y});
    if(side==='L') armPolys.L=poly; else armPolys.R=poly;
  }
  build('L'); build('R');
}

// ===== CSV 1枚読込み =====
function parseUnifiedCSV(text){
  const rows = text.split(/\r?\n/).filter(l=>l.trim()).map(l=>l.split(','));
  let start=0; if(rows[0][0]?.match(/name|名称|Name/i)) start=1;
  const map={}; for(let i=start;i<rows.length;i++){ const k=rows[i][0]?.trim(); if(!k) continue; map[k]={val:num(rows[i][1])}; }
  const get=(k,def=0)=> map[k]? num(map[k].val) : def;

  const HA={x:get('チェーン/ホイスト交点_X座標',0), y:get('チェーン/ホイスト交点_Y座標',0)};
  const cf={x:get('チェーン/吊具天秤交点_X座標',0), y:get('チェーン/吊具天秤交点_Y座標',-500)};
  const L1=get('吊具天秤長さ_L1',2340), H1=get('吊具天秤高さ_H1',120), m1=get('吊具天秤重量_m1',180);
  const frameCOM={x:cf.x, y:cf.y - H1/2}; // 上面→COM

  // アーム支点（世界→ローカルへ）
  const PLw={x:get('左側アーム回転中心座標_X',-700), y:get('左側アーム回転中心座標_Y',-620)};
  const PRw={x:get('右側アーム回転中心座標_X', 700), y:get('右側アーム回転中心座標_Y',-620)};
  const PLI={x:PLw.x-frameCOM.x, y:PLw.y-frameCOM.y};
  const PRI={x:PRw.x-frameCOM.x, y:PRw.y-frameCOM.y};

  const Hh=get('ホイスト高さ_Hh',200), Lh=get('ホイスト長さ_Lh',400);
  const chainLen=get('チェーン長さ_Lc',500);

  // CAB
  const cab={ mass:get('CAB重量_mcab',400), W:get('CAB幅_Lcab',1800), H:get('CAB高さ_Hcab',1200),
              cg:{x:get('CAB重心_Gcab_X座標',7), y:get('CAB重心_Gcab_Y座標',-1800)}, mu:0.30, cphi:10, notch:0 };

  model.anchors={HOIST_ANCHOR:HA, FRAME_COM:frameCOM, CHAIN_A_LOCAL:{x:cf.x-frameCOM.x, y:cf.y-frameCOM.y},
                 PIVOT_L_LOCAL:PLI, PIVOT_R_LOCAL:PRI};
  model.hoistRect={Lh,Hh}; model.beam={mass:m1, span:L1, height:H1};
  model.chain={L:chainLen}; model.cab=cab;

  // 状態初期化
  xt=HA.x; vt=0; xF=frameCOM.x; yF=frameCOM.y; vFx=0; vFy=0; psi=0; wF=0;
  phi=0; omega=0; cvx=0; cvy=0; cx=cab.cg.x;

  // 棚を生成して CAB を“乗せる”
  buildArmsAndShelves();
  const yShelfAvg = shelvesWorld.reduce((s,seg)=>s+(seg.y0+seg.y1)/2,0)/shelvesWorld.length;
  cy = yShelfAvg - (model.cab.H/2 - model.cab.notch);

  solveChainPosition(6);
  t=0;
}

// ===== チェーン拘束（剛体長） =====
function solveChainPosition(iter=3){
  for(let k=0;k<iter;k++){
    const H={x:xt,y:model.anchors.HOIST_ANCHOR.y}, A=posF(model.anchors.CHAIN_A_LOCAL);
    const r=sub(A,H); const L=len(r)||1; const n={x:r.x/L,y:r.y/L}; const C=L-model.chain.L;
    if(Math.abs(C)<1e-6) return;
    const rA=rot(psi,model.anchors.CHAIN_A_LOCAL);
    const w=1/model.beam.mass, wrot=1/Math.max(1e-9,I_frame());
    const s = rA.x*n.y - rA.y*n.x;
    const dl=C/(w + s*s*wrot);
    xF -= w*n.x*dl; yF -= w*n.y*dl; psi -= wrot*s*dl;
  }
}
function solveChainVelocity(){
  const H={x:xt,y:model.anchors.HOIST_ANCHOR.y}, vH={x:vt,y:0};
  const A=posF(model.anchors.CHAIN_A_LOCAL), vA=velAt(model.anchors.CHAIN_A_LOCAL);
  const r=sub(A,H); const L=len(r)||1; const n={x:r.x/L,y:r.y/L};
  const vrel=((vA.x-vH.x)*n.x + (vA.y-vH.y)*n.y)/1000;
  const rAm=rot(psi,model.anchors.CHAIN_A_LOCAL); const rAm_m={x:rAm.x/1000,y:rAm.y/1000};
  const K=1/model.beam.mass + ((rAm_m.x*n.y - rAm_m.y*n.x)**2)/I_frame();
  let J=-vrel/K; if(J<0) J=0;
  vFx += (-n.x*1000*J)/model.beam.mass; vFy += (-n.y*1000*J)/model.beam.mass;
  wF  += ( (rAm_m.x*(-J*n.y) - rAm_m.y*(-J*n.x)) )/I_frame();
}

// ===== ステップ =====
let keyL=false,keyR=false,brake=false;
addEventListener('keydown',e=>{if(e.code==='ArrowLeft')keyL=true;if(e.code==='ArrowRight')keyR=true;if(e.code==='Space')brake=true;if(e.key==='p'||e.key==='P')togglePause();if(e.key==='r'||e.key==='R')doReset();});
addEventListener('keyup',e=>{if(e.code==='ArrowLeft')keyL=false;if(e.code==='ArrowRight')keyR=false;if(e.code==='Space')brake=false;});

function step(){
  const dt=model.sim.dt, gmm=model.sim.g;

  // 台車操作
  let u=0; if(keyL)u-=model.hoist.a_cmd; if(keyR)u+=model.hoist.a_cmd; if(brake)u+=-3*vt;
  vt += (u - model.hoist.ccart*vt)*dt;
  vt = Math.max(-model.hoist.vmax, Math.min(model.hoist.vmax, vt));
  xt += vt*dt;

  // 重力（下向き）
  vFy += (-gmm/1000)*dt;

  // チェーン拘束 → 天秤更新
  solveChainPosition(3);
  solveChainVelocity();
  xF += vFx*dt; yF += vFy*dt; psi += wF*dt;

  // アーム＆棚を天秤に追従して再生成
  buildArmsAndShelves();

  // ===== CAB と棚の接触（法線=天秤の上方向 ey、接線=ex）=====
  const Icab=I_cab();
  const ex=rot(psi,{x:1,y:0}), ey=rot(psi,{x:0,y:1}); // 法線=ey
  const cph=Math.cos(phi), sph=Math.sin(phi);
  const yTopOffset = model.cab.H/2 - model.cab.notch;

  for(const seg of shelvesWorld){
    // 面の代表点（中央）と“中央 x”
    const S = {x:(seg.x0+seg.x1)/2, y:(seg.y0+seg.y1)/2};
    const xs = S.x;

    // CAB 上端の、世界x=xs に一致する点を解く（CABが回転していてもOK）
    let xoff;
    if(Math.abs(cph)<1e-6){ xoff=0; } else { xoff = (xs - cx + sph*yTopOffset)/cph; }
    const xmin=-model.cab.W/2+20, xmax=model.cab.W/2-20;
    if(xoff<xmin) xoff=xmin; if(xoff>xmax) xoff=xmax;

    const P = { x:cx + cph*xoff - sph*yTopOffset, y:cy + sph*xoff + cph*yTopOffset };

    // 面法線方向の距離 φ = n·(P - S)   →  φ < 0 なら面を貫通している
    const phi_p = (P.x-S.x)*ey.x + (P.y-S.y)*ey.y;
    if(phi_p <= 1e-3){ // 衝突
      const n=ey, tdir=ex;
      const r={x:(P.x-cx)/1000, y:(P.y-cy)/1000};
      const vP={x:cvx - omega*(P.y-cy), y:cvy + omega*(P.x-cx)};

      const vrelN = (vP.x*n.x + vP.y*n.y)/1000;
      const K = 1/model.cab.mass + ((r.x*n.y - r.y*n.x)**2)/Icab;
      const Jn = Math.max(0, -vrelN/K);                // 法線
      cvx += (1000*Jn*n.x)/model.cab.mass; cvy += (1000*Jn*n.y)/model.cab.mass; omega += ((r.x*Jn*n.y - r.y*Jn*n.x))/Icab;

      const vrelT = (vP.x*tdir.x + vP.y*tdir.y)/1000;  // 摩擦
      const Kt = 1/model.cab.mass + ((r.x*tdir.y - r.y*tdir.x)**2)/Icab;
      const mu=model.cab.mu;
      const Jt_unc = - vrelT/Kt;
      const Jt = Math.max(-mu*Jn, Math.min(mu*Jn, Jt_unc));
      cvx += (1000*Jt*tdir.x)/model.cab.mass; cvy += (1000*Jt*tdir.y)/model.cab.mass; omega += ((r.x*Jt*tdir.y - r.y*Jt*tdir.x))/Icab;

      // 位置押し戻し（法線方向）
      const pen = -phi_p;
      if(pen>0){ cy += pen*ey.y*0.6; cx += pen*ey.x*0.6; }
    }
  }

  // CAB 自由運動
  cvy += (-gmm/1000)*dt;
  cx += cvx*dt; cy += cvy*dt;
  omega += (-model.cab.cphi*omega/Icab)*dt; phi += omega*dt;
}

// ===== 描画 =====
function draw(){
  const s=PPM(); resize(); const W=cv.width,H=cv.height; const ox=W*0.5, oy=H*0.15; const sx=x=>ox+x*s, sy=y=>oy-y*s;
  ctx.clearRect(0,0,W,H);

  // grid
  ctx.save(); ctx.strokeStyle='#1b2445'; ctx.lineWidth=1;
  for(let x=-8000;x<=8000;x+=200){ctx.beginPath();ctx.moveTo(sx(x),0);ctx.lineTo(sx(x),H);ctx.stroke();}
  for(let y=-4000;y<=4000;y+=200){ctx.beginPath();ctx.moveTo(0,sy(y));ctx.lineTo(W,sy(y));ctx.stroke();}
  ctx.restore();

  // hoist矩形（下辺中央=HOIST_ANCHOR）
  const ha=model.anchors.HOIST_ANCHOR;
  const topY = ha.y + model.hoistRect.Hh;
  ctx.fillStyle='#26d07c';
  ctx.fillRect(sx(xt)-model.hoistRect.Lh*s/2, sy(topY), model.hoistRect.Lh*s, model.hoistRect.Hh*s);

  // chain
  const A=posF(model.anchors.CHAIN_A_LOCAL);
  ctx.strokeStyle='#7bd6a8'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(sx(xt),sy(ha.y)); ctx.lineTo(sx(A.x), sy(A.y)); ctx.stroke();

  // beam（天秤）
  ctx.save(); ctx.translate(sx(xF), sy(yF)); ctx.rotate(-psi);
  ctx.fillStyle='#ff7070'; ctx.fillRect(-model.beam.span*s/2, -model.beam.height*s/2, model.beam.span*s, model.beam.height*s);
  // COM点
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // arms（天秤に追従）
  function drawPoly(poly){
    ctx.strokeStyle='#ff5a5a'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(sx(poly[0].x),sy(poly[0].y));
    for(let i=1;i<poly.length;i++) ctx.lineTo(sx(poly[i].x),sy(poly[i].y));
    ctx.stroke();
  }
  drawPoly(armPolys.L); drawPoly(armPolys.R);

  // 棚ハイライト
  ctx.strokeStyle='#ff9a9a'; ctx.lineWidth=8;
  for(const seg of shelvesWorld){ ctx.beginPath(); ctx.moveTo(sx(seg.x0),sy(seg.y0)); ctx.lineTo(sx(seg.x1),sy(seg.y1)); ctx.stroke(); }

  // 支点・アンカーなどマーク
  ctx.fillStyle='#fff';
  ctx.beginPath(); ctx.arc(sx(armRoots.L.x),sy(armRoots.L.y),3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(sx(armRoots.R.x),sy(armRoots.R.y),3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#7bd6a8'; ctx.beginPath(); ctx.arc(sx(xt),sy(ha.y),3,0,Math.PI*2); ctx.fill();

  // CAB
  ctx.save(); ctx.translate(sx(cx), sy(cy)); ctx.rotate(-phi);
  ctx.fillStyle='rgba(127,182,255,0.9)'; ctx.fillRect(-model.cab.W*s/2, +model.cab.H*s/2 - model.cab.H*s, model.cab.W*s, model.cab.H*s);
  // CG
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// ===== ループ・UI =====
let last=performance.now(), acc=0;
function loop(now){
  const el=(now-last)/1000; last=now;
  if(!paused){ acc+=Math.min(el,0.12); const dt=model.sim.dt; while(acc>=dt){ step(); t+=dt; acc-=dt; } }
  draw(); requestAnimationFrame(loop);
}
function setStatus(s){ document.getElementById('status').textContent=s; }

async function loadUnifiedFromRepo(){
  try{ const r=await fetch('要素数値情報.csv'); if(!r.ok){ setStatus('要素数値情報.csv が見つかりません'); return; }
       parseUnifiedCSV(await r.text()); setStatus('要素数値情報.csv を読込みました'); }
  catch(e){ console.error(e); setStatus('読込エラー: '+e.message); }
}
async function applyUnifiedFromLocal(){
  const f=document.getElementById('fileUnified').files[0];
  if(!f){ setStatus('CSVファイルを選択してください'); return; }
  parseUnifiedCSV(await f.text()); setStatus('ローカルCSVを反映しました');
}
function togglePause(){ paused=!paused; document.getElementById('pause').textContent=paused?'再開':'一時停止'; }
function doReset(){
  const ha=model.anchors.HOIST_ANCHOR;
  xt=ha.x; vt=0; xF=model.anchors.FRAME_COM.x; yF=model.anchors.FRAME_COM.y; vFx=0; vFy=0; psi=0; wF=0;
  phi=0; omega=0; cvx=0; cvy=0; cx=model.cab.cg.x;
  buildArmsAndShelves();
  const yShelfAvg=shelvesWorld.reduce((s,seg)=>s+(seg.y0+seg.y1)/2,0)/shelvesWorld.length;
  cy = yShelfAvg - (model.cab.H/2 - model.cab.notch);
  solveChainPosition(6); t=0; paused=false;
  document.getElementById('pause').textContent='一時停止'; setStatus('リセットしました');
}
document.getElementById('loadUnified').onclick=loadUnifiedFromRepo;
document.getElementById('applyUnified').onclick=applyUnifiedFromLocal;
document.getElementById('pause').onclick=togglePause;
document.getElementById('reset').onclick=doReset;

// 起動
requestAnimationFrame(loop);
</script>
</body>
</html>
